[TOC]

# 刷题笔记

以下刷题的经验都是按照自己的写法总结的一些经验，不同解法要注意的事项不同



## 1.杂项

### 50.pow(快速幂)

```
解题思路:
根据给定参数，先把幂次转成longlong
看幂次是不是负数，如果是负数，把x转为1/x,n为-n，return 快速幂函数
快速幂函数：
定义一个half，递归调用快速幂，也就是n次要/2,再看你当前的次幂，如果是偶数，那么结果就是
half*half，如果是奇数，结果就是x*half*half，递归的出口是当n == 0的时候，此时任何数的0次
都返回1.0

难点和细节： longlong，递归出口，half递归求值
```

***代码:***

```c++

```



### 73.矩阵置零

```
解题思路:
本题的普通解法是暴力，然后创建行列数组挨个置零，空间为O（n+m）
空间为O(1)解法的方法是，以第0行和第0列为标记，假如第二行，第二列的元素为0，那么就把第零行
第二列的元素置为0，第二行第0列的元素置为0
再次遍历，每次遍历到的元素看看他的第0行和第0列的0的情况，如果是0，说明这个元素也该是0

但是需要注意的是假如第零行第零列本来就有0，我们在最开始给个列的bool标记，在第一次遍历的时候
外层从0开始，内层从1开始，if(matrix[i][0] == 0)isCol = true; 这样就能知道第零列该不该置为0了
而第一行的话，我们在第一次遍历的时候，会把对应行数的第0列的值和对应列数第0行的值置为0，
也就是说如果第零行里本来有0，那么经过第一次遍历，matrix[0][0]一定等于0

这样最后在处理0行0列的时候就可以靠matrix[0][0] == 0处理行， if(isCol)处理列，需要注意
0行先处理，列后处理，假如先处理列了，那么会把第0列全都置为0，这样第一个元素就不能作为判断根据了


难点和细节：第一次遍历里外层开始的地方，借用0行0列的标记理解，第二次遍历置零条件的理解
0行0列本来有0的处理
```

***代码:***

```

```



### 75.颜色分类

```
解题思路:
本题为技巧题，需要三个指针，low，mid，high
分别代表是，指向下一个该放0的位置，遍历数组，指向下一个该放1的位置
采用交换思想，以mid为遍历的元素，看它的值是多少，如果是0说明该和low指针交换然后都偏移，2说明该和high换，但是换完后high--mid不动，=1，mid偏移就行

难点和细节：三指针交换思想
```

***代码:***

```c++
    //荷兰国旗问题
    void sortColors(vector<int>& nums) {
        int low = 0;//指向下一个该放0的位置
        int mid = 0;//遍历数组
        int high = nums.size()-1;//指向下一个该放1的位置

        while(mid <= high){
            if(nums[mid] == 0){
                //交换完都偏移
                swap(nums[mid++],nums[low++]);
            }
            else if(nums[mid] == 2){
                //只high偏移，因为换过来还要判断是不是0
                swap(nums[mid],nums[high--]);
            }
            else{
                //等于1偏移mid就行
                ++mid;
            }
        }
    }
```



### 31.下一个排列

```
解题思路:
本题为技巧题
共计四个步骤就能做出这道题
1.先从后往前找到第一个下降区间，找到了说明就找到了第一个可以增大的点
2.如果没有可增大的点，说明是递减序列，直接反转，得到最小
3.找到第一个比可增大点大的元素(如果比它小就越过)，交换
4.反转第一次交换的位置到末尾(因为从交换点开始，除了和它交换的元素，其他元素都比它小，所以要进行反转，把小的弄前面来)

难点和细节：后往前找，反转后续
```

***代码:***

```c++
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        int firstIndex = -1;

        // 找到第一个可增大的点
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] < nums[i + 1]) {
                firstIndex = i;
                break;
            }
        }

        if (firstIndex == -1) {
            // 如果没有找到可增大的点，说明当前序列为最大序列，直接反转整个数组
            reverse(nums.begin(), nums.end());
            return;
        }

        // 找到第一个比 nums[firstIndex] 大的最小元素，交换
        for (int i = n - 1; i > firstIndex; --i) {
            if (nums[i] > nums[firstIndex]) {
                swap(nums[i], nums[firstIndex]);
                break;
            }
        }

        // 反转第一次交换的位置直到末尾
        reverse(nums.begin() + firstIndex + 1, nums.end());
    }
```



### 287.寻找重复数

```
解题思路:
本题为技巧题
本题说的范围是1-n，所以二分的时候有点不太一样
左界限开始为1，右为nums.size()-1
然后我们要选定一个中间值，然后统计数组里的所有数看看小于等于中间数的数有多少
如果这个值大于了中间数，说明重复的数一定在中间数到中间数左边
否则就在右边，这一点比较难以理解，叫抽屉原理
比如1，5，3，2，2，4，中间数为3，那么正常来讲如果没有重复数的话，小于等于3的应该是1，2，3
但是如果重复了，小于等于3的数的个数就一定比3大，所以能推断出重复的数在3的左边

难点和细节：技巧二分
```

***代码：***

```c++
    int findDuplicate(vector<int>& nums) {
        int left = 1;
        int right = nums.size()-1;//1-n

        while(left < right){
            int mid = left + (right - left)/2;
            int count = 0;
            for(int num:nums){
                if(num <= mid){
                    count++;
                }
            }

            if(count > mid){
                right = mid;
            }
            else{
                left = mid + 1;
            }
        }

        return left;
    }
```

### 48.旋转图像

```
解题思路:
矩阵问题，此题为技巧题，做过了记住方法就行
先根据斜对角线进行转置矩阵，就是交换对角线两侧元素，把行变为列
然后每行反转，就能得到九十度旋转后的矩阵
难点和细节：行变列反转
```

***代码:***

```c++
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        //根据斜对角，交换元素(转置矩阵),其实就是把行变为列了
        for(int i = 0;i < n-1;i++){
            for(int j = m-1;j > i;j--){
                swap(matrix[i][j],matrix[j][i]);
            }
        }

        //每行反转
        for(int i = 0;i < n;++i){
            reverse(matrix[i].begin(),matrix[i].end());
        }

    }
```

### 240.搜索二维矩阵Ⅱ

```
解题思路:
和搜索二维矩阵1不同的是，每一行的每个元素不一定比下一行小了
我们可以选定右上角为基准值，然后往下找
如果当前元素小于target往左移动，如果大就往下移动，最后如果出界了说明没找到元素
反之则找到了
其实选定右上角之后你可以发现，你能把这个矩阵抽象成为一个搜索树，这样查找就方便了许多
难点和细节：选基准值
```

***代码：***

```c++
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row = matrix.size();
        int col = matrix[0].size();

        //从左上角开始搜起
        int curRow = 0;
        int curCol = col-1;

        while(curRow >= 0&&curRow < row &&curCol >= 0 &&curCol < col){
            if(matrix[curRow][curCol] > target){
                curCol--;
            }
            else if(matrix[curRow][curCol] < target){
                curRow++;
            }
            else{
                return true;
            }
        }  

        return false;
    }
```



## 2.链表

### 2.两数相加

```
解题思路:
此题不能简单的遍历链表取得整数值然后相加，因为会整数溢出，就算longlong也一样
解法是像普通手算两数相加一样，先定义一个虚拟头，和一个表尾，一个进位位
循环处理当条件成立时l1 || l2 ||carry，然后l1和l2两个指针的值加到carry进位位里去，分别向后偏移
然后让表尾的next指向new ListNode(carry % 10)拿到此位的结果,carry/=10拿到下一位该加的值
然后偏移表尾
最后返回虚拟头的next

难点和细节： 进位位处理，虚拟头的定义，双指针上下相加思想
```

***代码:***

```

```



### 148.排序链表

```
此题综合性较强，用到了合并链表，和找链表中点，归并排序，分治等思想
解题思路:
调用sortList函数，传入头和尾进行排序，找到使用快慢指针中间节点，然后递归调用中间节点两边排序
但是由于要合并，所以return merge(sortList(head,mid),sortList(mid,tail));要这么写
递归出口条件是，0个或1个不用排了，也就是头为空和头的下一个是尾的时候

合并部分:新建虚拟头代表新的链表，虚拟头尾指向虚拟头，head1标记，head2标记
循环判断head1和head2的标记节点的值哪个更小，小的接在虚拟头的尾巴上，然后对应的标记后移继续比
在看看俩链表哪个剩余了，在接一次，返回虚拟头的next

难点和细节: 分治思想，第一次调用sortlist函数的尾要传空值，
递归出口条件的判断(1个节点时，next置为空)

//还有自己的数组写法，比较low，就是提取链表元素到数组然后排序，在放回新链表
```

***代码:***

```

```



### 147.LRU缓存

```
解题思路:
正常写法是用一个哈希表存key和链表节点，链表节点里存key和value还有前驱后继

我的写法:哈希存key和一个链表的迭代器(也就是这个key对应在链表里的位置),put没什么难度，
看看重复吗，重复覆盖，不重复看看超没超出容量，没超出就放在map里，value存的是链表表头
因为新插入的节点最近被使用过，所以放在表头，链表里前插一个pair

get函数 看看有没有，没有返回-1，有
关键来了，要先把对应key在链表里的元素删了，在插回表头，也就是给一个迭代器在链表里的位置，把此元素删了在添加回链表表头
让map[key] value值重新回到表头，然后返回表头的.second就行   可以通过splice函数做  三个参数的意思是，1插到哪里，2是要删除元素所在容器，3是要删除元素的位置也就是迭代器

难点和细节： 哈希存值，双向链表使用，splice函数
```

***代码:***

```

```

### 23.合并K个升序链表

```
解题思路:
此题还有优先队列的解法，此处不做说明，只说分治法
核心函数有两个，一个merge，负责分，一个mergeTwoLists负责合
分函数老生常谈，每次取中点，然后递归调用自身，分成两个链表，最后return 合并函数，递归出口为left == right，也就是不能在分了，只有一个元素了，就是有序的

合函数:如果其中一个链表为空，直接返回另一个链表
否则进行数值比较，难点在此处，如果l1->val<l2->val  l1->next = mergeTwoLists(l1->next,l2);
此处的意思是l1小，那么头节点就是l1，然后l1的下一个就是 递归调用合并函数，拿l1的下一个和l2比
举例子，l1为  1，3   l2 为2   那么就是l1先为1，然后拿l1的next也就是3和l2的2比  3大于2，所以返回的是l2，所以l1的next = l2，假如l2还有值，l2里也会递归调用合并

难点和细节：分治思想，合并函数的连接处理
```

***代码:暴力比较***

```c++
	    if(lists.empty()) return nullptr;
        ListNode *dummy = new ListNode(0);
        ListNode *tail = dummy;
        while(true){
            int min = INT_MAX;
            ListNode *tmp = nullptr;
            int index = -1;
            int cntNull = 0;
            for(int i = 0;i < lists.size();++i){
                if(lists[i] == nullptr){
                    cntNull++;
                    continue;
                }
                if(lists[i]->val < min){
                    min = lists[i]->val;
                    tmp = lists[i];
                    index = i;
                }
            }
            if(cntNull == lists.size()){
                break;
            }
            tail->next = tmp;
            tail = tail->next;
            lists[index] = lists[index]->next;
        }
        
        return dummy->next;
```

***代码:分治***

```c++
ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.empty()) return nullptr;

        return merge(lists,0,lists.size()-1);
    }

    ListNode* merge(vector<ListNode*>& lists, int left, int right){
        if(left == right) return lists[left];

        int mid = left + (right - left) / 2;
        ListNode *l1 = merge(lists,left,mid);
        ListNode *l2 = merge(lists,mid+1,right);

        return mergeTwoLists(l1,l2);
    }

    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2){
        if(!l1) return l2;
        if(!l2) return l1;

        if(l1->val < l2->val){
            l1->next = mergeTwoLists(l1->next,l2);
            return l1;
        }
        else{
            l2->next = mergeTwoLists(l2->next,l1);
            return l2;
        }
    }
```





## 3.图论

### 207(210)课程表1，2  有向无权图(拓扑排序的应用)

```
解题思路:
首先计算每个课程的入度情况，数组是一个二维的，一对一对的，例如[0,1]就是你想学0课程得先学1课程
这样的话，用一个一维数组存储每个课程的入度，遍历，然后arr[0] ++就ok，然后在存储邻接关系，
因为学完一个课程，对应的依赖关系要删除，也就是入度要--，搞个二维数组，二维数组对应的下标就是
哪个元素，二维数组里面的一维数组就是当前下标元素的后继课程，所以adjacent[arr[1]].pushback(arr[0])
,找到无前驱也就是无依赖的节点入队，当队列不为空，循环出队，然后对应邻接的点入度--，如果-为0
继续入队，直到队列为空，最后判断出队节点数和课程数相等与否得出答案
```

***代码1***

```c++
bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        //计算各个课程先修课的数量
        int n = prerequisites.size();
        deque<int> m_deque;
        vector<vector<int>> adjacent(numCourses);//邻接表
        //入度数组
        //谁(下标)的入度是多少
        vector<int> indegrees(numCourses);
        
        for(auto &cp :prerequisites){
            indegrees[cp[0]]++;
            //! 例如[1,0]就是adjacent[0].push_back(1);
            //! 也就是说0的后继节点有1
            adjacent[cp[1]].push_back(cp[0]); 
        }
        //找到先修课为0的课程，入队
        for(int i = 0;i<indegrees.size();i++){
            if(indegrees[i] == 0){
                m_deque.push_back(i);
            }
        }

        //出队，把与他邻接的课程的依赖数-1(循环)
        while(!m_deque.empty()){
            int tmp = m_deque.front();
            m_deque.pop_front();
            //! 出队一个元素说明处理学完了一个课程，只要最后归零说明全部学完
            numCourses--;

            for(auto &cur:adjacent[tmp]){
                //adjacent[tmp][i]为出队元素tmp在邻接表里与它相连的节点，也就是依赖它的节点
                if(--indegrees[cur] == 0){
                    m_deque.push_back(cur);
                }

            }

        }

        //看出队节点数目和数组长度一致吗，一致true，否则false
        if(numCourses == 0) return true;
        return false;
    }
```

***代码2***

```c++
vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        int n = prerequisites.size();
        
        vector<int> indegrees(numCourses);
        vector<vector<int>> adjacent(numCourses);
        deque<int> m_deque;
        vector<int> result;
        //计算入度和邻接情况
        for(auto &cp:prerequisites){
            indegrees[cp[0]]++;
            adjacent[cp[1]].push_back(cp[0]);
        }
        //找到入度为0的节点入队
        for(int i = 0;i < numCourses;i++){
            if(indegrees[i]  == 0){
                m_deque.push_back(i);
            }
        }

        while(!m_deque.empty()){
            int tmp = m_deque.front();
            m_deque.pop_front();
            numCourses--;
            result.push_back(tmp);

            for(auto &cur:adjacent[tmp]){
                if(--indegrees[cur] == 0){
                    m_deque.push_back(cur);
                }
            }
        }

        if(numCourses == 0) return result;

        return {};
    }
```



### 994.腐烂的橘子

```
解题思路:
这种图论的题有固定模板，本题是bfs，先套模板，在根据题的不同进行细微变动
本题的关键在于新鲜的处理以及分钟何时++，搞清楚这俩此题会很好做
bfs的模板一般借助队列，队列里存一对pair代表x和y
首先遍历图，遇到新鲜的就往新鲜数里+1个，不新鲜的就入队等待处理
接下来处理队列，处理队列的关键是我们什么时候++分钟，不能简单地处理完一个就++，也不能简单的处理一轮就++，而是应该在处理一轮的基础上，还把新鲜的橘子染成腐烂的橘子了(假如没把新鲜的变腐烂，此分钟不能加，题干意思)，在此基础上才能++，新鲜的--
最后看有没有新鲜的，如果还有说明处理不了了，返回-1，否则返回分钟数

难点和细节： bfs模板，新鲜堆和腐烂堆处理，分钟数何时加
```

***代码:***

```c++
int arr[4][2] = {{0,1},{1,0},{-1,0},{0,-1}}; //x轴y轴
    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();

        //定义新鲜集合和时间
        int fresh = 0,min = 0;

        queue<pair<int,int>> q;//保存x，y

        for(int i = 0;i < n;++i){
            for(int j = 0;j < m;++j){
                //新鲜+
                if(grid[i][j] == 1) fresh++;
                //腐烂入队
                else if(grid[i][j] == 2){
                    q.push({i,j});
                }
            }
        }

        while(!q.empty()){
            bool rotten = false;
            int qSize = q.size();

            for(int i = 0;i < qSize;++i){
                auto x = q.front();//拿到出队元素
                q.pop();

                for(int k = 0;k < 4;++k){
                    int nextx = x.first + arr[k][0];
                    int nexty = x.second + arr[k][1];

                    if(nextx >= 0 && nextx < grid.size() && nexty >= 0 && nexty < grid[0].size() && grid[nextx][nexty] == 1)
                    {
                        grid[nextx][nexty] = 2;
                        q.push({nextx,nexty});
                        rotten = true;
                        fresh--;
                    }
                }
            }
            if(rotten) min++;
        }

        return fresh ?-1:min;

    }
```

### 208.实现前缀树

```
解题思路:
此题为前缀树(字典树的实现)
初次做这种题建议使用数组形式模拟树形结构(还有树形式构建)，定义二维数组1000000行26列代表每行的26个字母，也就是从任意一个节点开始最多26条边，再定义一个终结点数组和当前节点个数

插入流程:
定义一个当前指针指向根，遍历字符串，把每个字母-'a'得到对应的数组下标，看看数组中有没有这个节点，如果有直接偏移指针到它，没有就为数组赋值，注意此时赋的值是当前节点个数，用来模拟它是第几个节点，循环结束最后标记终结点

查找流程:
和插入大体一样，只是在判断是否查找到的时候不同，两种情况，一种是没有边返回，一种是走到最后还不是终结点返回

查前缀:
与查找流程一样，在最后不同，不论是不是终结点都返回true

难点和细节：前缀树的理解
```

***代码：***

```c++
class Trie {
public:
    Trie():nodeCount(1){
        memset(trie,0,sizeof(trie));
        memset(terminate,0,sizeof(terminate));
    }
    
    void insert(string word) {
        int len = word.size();
        int cur = 0;

        for(int i = 0;i < len;++i){
            int c = word[i] - 'a';
            //当前行连接的没有这个点
            if(!trie[cur][c]){
                //第nodeCount个节点
                trie[cur][c] = nodeCount;//此处直接给nodecount，大于0说明有边，对应字母看下标就行
                ++nodeCount;
            }
            //移动当前位置
            cur = trie[cur][c];
        }
        //最后标记成终结点
        terminate[cur] = 1;
    }
    
    bool search(string word) {
        int len = word.size();
        int cur = 0;
        for(int i = 0;i < len;++i){
            int c = word[i] - 'a';
            //如果没边
            if(!trie[cur][c]) return false;
            cur = trie[cur][c];
        }
        //如果走到最后了还不是终结点
        if(!terminate[cur]) return false;
        return true;
    }
    
    bool startsWith(string prefix) {
        int len = prefix.size();
        int cur = 0;
        for(int i = 0; i < len; ++i){
            int c = prefix[i] - 'a';
            // 如果没有边
            if(!trie[cur][c]) return false;
            cur = trie[cur][c];
        }
        // 如果走到最后了，无论是否是终结点，都返回 true
        return true;
    }

public:
    int trie[1000000+10][26];
    int terminate[1000000+10];
    int nodeCount;
};
```



## 4.回溯



### 46(47).全排列和全排列二

```
解题思路:
全排列的基本思想就是把数组里的元素抽象成树，搞一个used数组，标志这个元素有没有使用过
回溯的出口条件是，一条路径上的长度等于数组里的元素就添加到结果里，然后return
核心就是遍历每一层，如果这个元素没被使用过，把使用数组标为true，添加路径，然后递归回溯函数
下一轮就走到下一层，发现有用过的就continue;然后再次添加，直到收集完结果，要pop_back路径数组
然后使用数组置会false;
难点和细节： used数组，循环回退的理解


全排列二，在此基础上多了重复元素，也就是说同一层次不能选两个相同元素，但是可以不同层次选
因此，我们要先排序，才可以用数组的相邻下标来进行判断两个元素是否相同，如果相邻数组元素相同
并且使用数组的值为false，也就是说明这是同一层次，因为如果前一个元素的使用是true，说明已经
开始下一层的处理了，只有是false才是同层次的处理，这种情况直接continue：
难点和细节： 排序思想，条件的判断 
```

***代码1：***

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int> &nums,vector<bool> &used){
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }

        for(int i = 0;i < nums.size();++i){
            if(used[i] == true) continue;
            used[i] = true;
            path.push_back(nums[i]);
            backTracking(nums,used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        res.clear();
        path.clear();
        vector<bool> used(nums.size(),false);
        backTracking(nums,used);

        return res;
    }
};
```

***代码2：***

```c++
vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int>& nums,vector<bool> &used){
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }

        for(int i = 0;i<nums.size();i++){
            //这里必须是没用过，如果用过了说明在不同层，是可以继续的
            if(i > 0 &&nums[i] == nums[i-1] &&used[i-1] == false){
                continue;
            }
            if(used[i] == false){
                used[i] = true;
                path.push_back(nums[i]);
                backTracking(nums,used);
                path.pop_back();
                used[i] = false;
            }
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        res.clear();
        path.clear();
        sort(nums.begin(), nums.end()); // 排序
        int n = nums.size();
        vector<bool> used(n,false);
        backTracking(nums,used);

        return res;
    }
```



### 78.子集

```
解题思路:
此题是回溯算法中的组合问题，既然是组合，那么每一层开始下标就不能是从0开始，因为会重复，但如果是排列的话可以从0开始，因为[1,2]和[2,1]是不一样的
先套回溯模板，由于是组合，参数设定上有个开始下标
在每次回溯开始的时候都要添加一下当前结果，为了不漏解，题目最开始有个空集，假如不在最开始添加就会漏掉
然后判断终止条件（不判断也行，因为如果大于，下面的循环进不去）
开始每次一层的处理，开始下标为startIndex，添加当前节点之后，调用回溯，开始下标为当前的+1，然后本节点处理完之后弹出
// Finished
// Your Input
// [1,2,3]
// Output (0 ms)
// [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
// Expected Answer
// [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
可以看到整个添加结果的顺序，从1开始逐节点路径添加
    
难点和细节：组合问题，开始下标处理
```

***代码:***

```c++
    vector<vector<int>> result;
    vector<int> path;
    void backTracking(vector<int>& nums,int startIndex){
        //先添加本次结果，要不然会漏掉自己
        result.push_back(path);
        //判断终止条件
        //此处不判断也行，因为如果大于，下面的循环进不去
        if(startIndex >= nums.size()) return;

        for(int i = startIndex;i < nums.size();++i){
            path.push_back(nums[i]);
            backTracking(nums,i+1);
            //回溯
            path.pop_back();
        }

    }

    vector<vector<int>> subsets(vector<int>& nums) {
        result.clear();
        path.clear();
        backTracking(nums,0);
        return result;
    }
```



### 39.组合总和

```
解题思路:
此题是回溯算法中组合的经典问题，既然是组合，那么同一种集合就不能出现，跟位置无关
首先套回溯模板，基础上多了个pathSum记录路径总和方便和target作比较，收集结果条件就是pathSum和target相等
接着就是每层的处理，如果pathSum加上当前元素>target那么就不能添加路径，略过此元素即可
else，把路径和加上当前元素，路径添加，开始回溯，为了去重我们需要一个startIndex用来当作开始的位置，每一层的startIndex都是i开始，因为自己可以重复取，只不过是同一层不能回头
难点和细节：去重，startIndex的处理
```

***代码:***

```c++
vector<vector<int>> res;
    vector<int> path;
    int pathSum;
    void backTracking(vector<int>& candidates, int target,int startIndex){
        if(pathSum == target){
            res.push_back(path);
            return;
        }

        //本层循环
        for(int i = startIndex;i < candidates.size();++i){
            if(pathSum + candidates[i] > target){
                continue;
            }
            else{
                pathSum += candidates[i];
                path.push_back(candidates[i]);
                //开始回溯
                backTracking(candidates,target,i);
                //回退
                path.pop_back();
                pathSum -= candidates[i];
            }
        }

    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        res.clear();
        path.clear();
        pathSum = 0;
        backTracking(candidates,target,0);
        return res;
    }
```

### 40.组合总和2

```
解题思路:
大体上与组合1一致，不同点在于，现在每个元素在一个组合里只能被使用一次，也就是说，同层次在不能回头的基础上，还不能选择自己，也就是startIndex不能从i开始了，要从i+1开始，同层次前后不能相等，也就是说需要排序了
所以在代码实现上就是多一个判断，i > startIndex(此条件作用是控制同层，假如不同层但元素相等是可以选择的)，candidates[i] == candidates[i-1]，同层相等元素不能选择

难点和细节：需要排序的思想控制同层相等元素的选取规则，条件判断不同层次但元素相同的选取规则
```

***代码:***

```c++
vector<vector<int>> res;
    vector<int> path;
    int pathSum;
    void backTracking(vector<int>& candidates, int target,int startIndex){
        if(pathSum == target){
            res.push_back(path);
            return;
        }

        //不判断也行
        if(startIndex >= candidates.size()){
            return;
        }

        //本层循环
        for(int i = startIndex;i < candidates.size();++i){
            if(i > startIndex&&candidates[i] == candidates[i-1]){
                continue;;
            }
            if(pathSum + candidates[i] > target){
                continue;
            }
            else{
                pathSum += candidates[i];
                path.push_back(candidates[i]);
                //开始回溯
                backTracking(candidates,target,i+1);
                //回退
                path.pop_back();
                pathSum -= candidates[i];
            }
        }

    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        res.clear();
        path.clear();
        pathSum = 0;
        //为了去重
        sort(candidates.begin(),candidates.end());
        backTracking(candidates,target,0);
        return res;
    }
```

### 22.括号生成

```
解题思路:
本题和普通的回溯不太一样，条件写起来很简单，但是理解比较困难
首先定义结果数组，收集条件是当前字符串长度一旦等于2*n了说明是n对括号，进行收集
这里我们的回溯过程隐藏在了函数的形参中，如果本层递归结束出栈，参数值不会改变
如果左括号数量还没到n就可以继续添加左括号，在看右括号，只要数量小于左括号就能保证整个括号是合法的
难点和细节：左右括号添加
```

***代码:***

```c++
	vector<string> res;
    void backTracking(string currentString,int n,int leftCount,int rightCount){
        //收集结果的条件
        if(currentString.length() == 2 * n){
            res.push_back(currentString);
            return;
        }

        //如果左括号数量还没到n，继续添加左括号
        if(leftCount < n){
            backTracking(currentString+"(",n,leftCount+1,rightCount);
        }

        //如果右括号数量小于左括号数量，继续添加右括号
        if(rightCount < leftCount){
            backTracking(currentString+")",n,leftCount,rightCount+1);
        }
    }
    vector<string> generateParenthesis(int n) {
        backTracking("",n,0,0);
        return res;
    }
```



### 131.分割回文串

```
解题思路:
类似组合问题，但是和组合问题不同的是不再是一个一个元素的选，而是一个范围一个范围切割的选
首先套回溯模板，然后收集结果的条件是startIndex的值>=s.size()说明切割到头了，不能再切了
可以看到类组合问题都需要这个startIndex来确保同层不会回头取，当然此题纵向也不能回头
首先判断每层startIndex到i的位置是不是回文，如果是回文可以添加进入路径，不是就继续
然后开始下一层的处理，因为不能回头，所以开始下标为i+1，回溯完再回退pop

难点和细节：切割范围概念，startIndex的处理
```

***代码:***

```c++
    vector<vector<string>> res;
    vector<string> path;
    bool isPalindrome(const string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (s[i] != s[j]) {
                return false;
            }
        }
     return true;
    }
    void backTracking(string s,int startIndex){
        //收集结果的条件
        if(startIndex >= s.size()){
            res.push_back(path);
            return;
        }

        for(int i = startIndex;i < s.size();++i){
            //横向关系，同层处理
            if(isPalindrome(s,startIndex,i)){
                string tmp = s.substr(startIndex,i-startIndex+1);
                path.push_back(tmp);
            }
            else{
                //不是回文就继续
                continue;
            }

            //纵向关系，回溯
            backTracking(s,i+1);
            path.pop_back();
        }


    }
    vector<vector<string>> partition(string s) {
        res.clear();
        path.clear();
        backTracking(s,0);
        return res;
    }
```

### 51.N皇后

```
解题思路:
第一次在二维里见到回溯可能会措手不及，但是其实和普通的回溯题区别不大
那么回溯就是要如何把问题抽象成树，我们可以把二维矩阵的每一行当作树的每一层，然后每一层都是从头开始选，只不过这里的选是加了条件的，也就是横行列，斜角都是不能选的，所以独立出来一个函数用来判断
那么什么时候是我们的收集条件呢，就是回溯的行数等于给定的n时，举个例子，假如4行，刚开始传为0，那么选到最后一行的时候行数应该是3，如果最后一行没有满足条件的，那么递归就会回退了，但如果有满足的条件就会进入下一层，也就是n=4的时候，所以直接收集结果就可以了，其他就是正常的回溯模板的过程

难点和细节:回溯函数参数设计，收集条件，检查符合条件
```

***代码:***

```c++
    vector<vector<string>> res;
    void backTracking(int n,int row,vector<string> &checkBoard){
        //不是n-1,因为到最后一行了发现还能放，那么还会进入一次递归
        if(row == n){
            res.push_back(checkBoard);
            return;
        }

        for(int col = 0;col < n;++col){
            //判断当前位置合法吗
            if(isValid(row,col,checkBoard,n)){
                checkBoard[row][col] = 'Q';
                //进入下一层，确保同一行不被选
                backTracking(n,row+1,checkBoard);
                checkBoard[row][col] = '.';
            }
        }
    }
    bool isValid(int row,int col,vector<string> &checkBoard,int n){
        //检查列
        for(int i = 0;i < row;++i){
            if(checkBoard[i][col] == 'Q'){
                return false;
            }
        }
        //检查45度
        for(int i = row - 1,j = col - 1;i >= 0&&j >= 0;--i,--j){
            if(checkBoard[i][j] == 'Q'){
                return false;
            }
        }
        //检查135度

        for(int i = row - 1,j = col + 1;i >= 0&&j < n;--i,++j){
            if(checkBoard[i][j] == 'Q'){
                return false;
            }
        }
        
        //可以看到没有对于横行的处理，因为在循环里已经确保了同层只会有一个元素被选择
        return true;
    }
    vector<vector<string>> solveNQueens(int n) {
        res.clear();
        vector<string> chessBoard(n,string(n,'.'));
        backTracking(n,0,chessBoard);
        return res;
    }
```



## 5.二叉树

### *543.二叉树的直径*

```
直径指的是，二叉树中两个节点之间的最长的路径
解题思路:
定义全局的res，对于根节点来说，最长的路径有两种选择，1是子树中有最长的路径，2是左边最长
+上右边最长 ，在递归的时候，求出左子树的长度和右子树的长度，返回值为左树和右树中最长的
后序遍历的时候，求完左右子树的长度，定义当前结果tmp = left + right 跟全局res比较，大的覆盖


难点和细节： 递归出口返回值为-1，理解最长路径的两种选择情况，函数返回值的设定为左子长度和右子
长度的最大值
```

***代码:***

```

```



### 98.验证二叉搜索树

```
此题有意思，目光不能短浅，仅仅看一个家族内的成员，需要看整根树
解题思路:
维护每一个节点的上界与下界，此节点必须大于下界小于上界，同时左右子树递归处理，也要满足条件
递归的传参是，假如是左子树，要小于父亲，所以上界变为父亲，下界还是父亲的下界
假如是右子树，要大于父亲，所以下界变为父亲，上界还是父亲的上界
难点和细节：维护的上下界，long
```

***代码:***

```c++
    bool isValidBST(TreeNode* root,long left = LONG_MIN,long right = LONG_MAX) {
        if(!root) return true;

        long cur = root->val;

        return cur > left && cur < right &&
            isValidBST(root->left,left,cur) &&
            isValidBST(root->right,cur,right);
    }
```



### 230.二叉搜索树中第K小的元素

```
解题思路:
此题较为简单，寻找第K小先明白二叉搜索树的性质，最小值一定出现在树的最左侧，接着根接着右，明确了遍历顺序为左根右，也就是一个中序的遍历顺序
那么就简单了，先往左侧递归，左侧处理完返回的时候，要把k值--，例如k为3，找到第三小的，3减为2，减为1，减为0，直到为0了，那么说明找到了想找的元素，把结果保存即可
难点和细节：遍历顺序(无其他难点)
```

***代码:***

```c++
    void dfs(TreeNode *node,int &k,int &result){
        if(!node) return;
        //左根右
        dfs(node->left,k,result);
        --k;
        if(k == 0){
            result = node->val;
            return;
        }
        dfs(node->right,k,result);
    }

    int kthSmallest(TreeNode* root, int k) {
        int result = 0;
        dfs(root,k,result);
        return result;
    }
```



### 199.二叉树的右视图

```
解题思路:
此题难度在理解题意，右视图不是光右子树，也不是光最右侧，而是目光所能看到的右边，可能在左子树也可能在右子树，首先想到的思路就是考虑层序遍历，把每一行的元素的值都装在一个二维数组里，这样从右侧看到的元素就是每个数组的最后一个元素，即可解决问题
难点和细节：层序遍历思想
```

***代码:***

```c++
	vector<int> res;
    vector<vector<int>> level;
    void levelOrder(TreeNode *root){
        if(!root) return;
        deque<TreeNode *> m_d;
        m_d.push_back(root);

        while(!m_d.empty()){
            vector<int> tmp;
            int n = m_d.size();

            for(int i = 0;i < n;++i){
                TreeNode *out = m_d.front();
                tmp.push_back(out->val);
                m_d.pop_front();

                if(out->left)
                    m_d.push_back(out->left);
                if(out->right)
                    m_d.push_back(out->right);
            }
            level.push_back(tmp);
        }

    }
    vector<int> rightSideView(TreeNode* root) {
        if(!root) return {};
        levelOrder(root);
        for(int i = 0;i < level.size();++i){
            res.push_back(level[i][level[i].size()-1]);
        }

        return res;
    }
```

### 114.二叉树展开为链表

```
解题思路:
此题难度不大，但是细节很关键，如果细节没掌握好就过不了
题干说了展开后的单链表应该和二叉树的前序遍历结果相同，那么我们就进行前序遍历，先定义虚拟头节点，和尾节点用来偏移，没遍历到一个节点就让tail->right = 节点  ，tail = tail->right，本来到此就应该结束，但由于我们移动tail的时候相当于改变了原树的right，那么right会丢失，所以在改变尾节点的指向之前要保存一下当前节点的左右节点再进行递归左右子树
难点和细节：保存，虚拟头和尾指针移动
```

***代码:***

```c++
    void preOrder(TreeNode *root, TreeNode *&tail) {
        if (!root) return;

        //必须要先保存一下
        TreeNode *left = root->left;
        TreeNode *right = root->right;

        tail->right = root;//如果不保存，此步会改变原树的右子
        tail->left = nullptr;  // 将左子树设置为null
        tail = tail->right;

        preOrder(left, tail);
        preOrder(right, tail);
    }
    void flatten(TreeNode *root) {
        if (!root) return;

        TreeNode *dummy = new TreeNode(0);
        TreeNode *tail = dummy;
        preOrder(root, tail);

        root = dummy->right;  // 更新原始树的节点
    }
```

### 105.从前序与中序序列中构造二叉树

```
解题思路:
想做懂此题需要理解，若已知前序中序，中序后序，都能构建出一个二叉树
首先定义一个哈希表，用于存储中序的值和对应下标的关系，以便我们能做到快速根据前序查找到对应中序的下标
定义关键性函数，参数设定比较重要，一个是前序的范围，一个是中序的范围
首先前序左边界的节点就是你本次要构建的节点，找到对应在中序的下标，计算对应左子树的数目，递归处理左右子树
左子树传参，前序左+1，前序左+左子树数目，中序左，构建的根的对应中序下标-1
右子树传参，前序左+左子树数目+1，前序右，构建的根的对应中序下标+1，中序右
难点和细节：函数参数设计，计算范围
```

***代码:***

```c++
    unordered_map<int,int> index;//哈希映射，为了在中序中快速定位下标
    TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right){
        if(preorder_left > preorder_right) return nullptr;

        int preorder_root = preorder_left;//前序的第一个节点即为根

        //在中序中定位
        int inorder_root = index[preorder[preorder_root]];

        //计算左子树的数目
        int leftTreeCount = inorder_root - inorder_left;

        //构建根
        TreeNode *root = new TreeNode(preorder[preorder_root]);

        //递归处理左右子树
        root->left = myBuildTree(preorder,inorder,preorder_left + 1,preorder_left + leftTreeCount,inorder_left,inorder_root-1);

        root->right = myBuildTree(preorder,inorder,preorder_left + leftTreeCount + 1,preorder_right,inorder_root + 1,inorder_right);

        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();

        for(int i = 0;i < n;++i){
            index[inorder[i]] = i;
        }

        return myBuildTree(preorder,inorder,0,n-1,0,n-1);
    }
```

### 437.路径总和 iii

```
解题思路:
此题与之前做过的二叉树求解路径的题不同的地方在于，不是从根出发也行，也就是考虑情况的时候不但要从根开始，他的左子右子也要做同样的处理，在算路径的时候要注意是个回溯的过程，如果preDfs中targetSum的值是引用记得函数返回的时候把刚才减去的值加回来，但是用值传递的方式会隐含了回溯的过程，所以在主函数内调用dfs函数求解当前节点出发的所有路径，然后在递归主函数求解左子右子出发的所有路径

难点和细节：两个递归的处理，回溯概念，targetSum越界问题
```

***代码:***

```c++
    int res;
    void preDfs(TreeNode *root,long long targetSum){
        if(!root) return;

        targetSum -= root->val;
        if(targetSum == 0) res ++;
        
        preDfs(root->left,targetSum);
        preDfs(root->right,targetSum);
    }
    int pathSum(TreeNode* root, int targetSum) {
        if(!root) return 0;

        preDfs(root,targetSum);

        pathSum(root->left,targetSum);
        pathSum(root->right,targetSum);

        return res;
    }
```

### 236.二叉树的公共祖先

```
解题思路:
本题不难，重要的是几种情况的考虑
1.要找的节点在当前节点的左子树和右子树中，也就是left和right都返回了，说明公共祖先就是root(当前节点)
2.要找的两个节点只在左子树中，那么往下递归找left的时候，碰到root==p||root==q的时候直接返回root就行，因为此时当前节点right为空，全部要找的节点都在左子树，那么你找到的第一个节点就是它的祖先
3.要找的两个节点都在右子树中，同样的道理不多赘述

还有一种解释比较好理解，祖先吗，无非两种情况，俩节点在左右里，或者都在一边里，那么我们求一下当前root的left和right就行了，也就是往左和往右递归，碰到那个节点就返回给它就行了，如果左节点存在右不存在，说明都在左了，那你返回的第一个节点就是祖先，如果左右都存在，那就说明root是祖先，或者右存在左不存在，一样道理


难点和细节：几种情况的分析，对于祖先出现的理解
```

***代码***

```c++
    TreeNode *recur(TreeNode *root, TreeNode* p, TreeNode* q){
        if(!root) return nullptr;
        if(root == p||root == q) return root;

        TreeNode *left = recur(root->left,p,q);
        TreeNode *right = recur(root->right,p,q);

        if(!left) return right;
        if(!right) return left;

        return root;
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return recur(root,p,q);
    }
```

### 124.二叉树中的最大路径和

```c++
解题思路:
此题难度为hard，但是一旦掌握了逻辑其实很好做
首先要明确路径的概念，一个点到另一个点之间所有相邻节点的值相加
做二叉树的任何题基本都离不开递归，但是递归不要往深了思考，先从根处分析，最大的路径和可能出现在哪里呢?

//以下分析可以后看，先看代码理解更深
1.经过根节点，也就是左子中有一个最大的正的路径 + 根节点值 + 右子中有一个正的最大路径
	1.1 经过根节点，但不经过右子树，说明左子有正的最大路径，根为正，右子路径为负的
	1.2 经过根节点，但不经过左子树，说明右子有正的最大路径，根为正，左子路径为负的
2.不经过根节点，在左子树。也就是左子树里有一条最大正路径，根为负的，并且右子不能弥补根负那么多
	2.1与上一条相反

综合来看，求解过程就是，求出当前节点的左子和右子的最大贡献值（递归），并且和0比较，如果比0小说明没必要加上了，没有帮助，拿当前节点的值加上左右子的最大贡献度 与  最大结果进行比较

函数返回值为 当前节点值 + 左右子中贡献大的那个(因为是一条路径上的，所以不能左右子都加上)
    
难点和细节：求解左子右子最大路径逻辑，函数返回值设计
```

***代码:***

```c++
    int maxGain(TreeNode *root,int &maxSum){
        if(!root) return 0;
        //左子中的最大贡献(左子最大路径)
        int left = max(maxGain(root->left,maxSum),0);
        //右子中的最大贡献(右子最大路径)
        int right = max(maxGain(root->right,maxSum),0);

        //当前的最大路径
        int curPath = root->val + left + right;

        //更新最大
        maxSum = max(maxSum,curPath);

        //返回当前的加上左子和右子中最大的那一个，因为是一条路径，不能既加left又加right
        return root->val + max(left,right);

    }
    int maxPathSum(TreeNode* root) {

        int maxSum = INT_MIN;
        maxGain(root,maxSum);
        return maxSum;
    }
```



## 6.字符串

### 28.找出字符串中第一个匹配项的下标

```
解题思路:
此题用暴力解法谁都会，所以这里应用kmp或者sunday，我选择了kmp
kmp算法的求解步骤为:
求next数组，kmp匹配，相等两个指针都后移，不相等子串指针要往前移，具体怎么移动就涉及到kmp的知识了，要移动到前一个字符的next数组值的位置，进入下次比较，如果回退到头了说明没有能利用的条件了，只能主串后移一位重新匹配
难点和细节：KMP算法
```

***代码:***

```c++

‘void getNext(vector<int> &next,string needle){
        //初始化
        next[0] = 0;
        //前缀末尾
        int j = 0;
        for(int i = 1;i < needle.size();++i){
            //不相等的时候要回退
            while(j > 0 && needle[i] != needle[j]){
                //回退到上次匹配到的最大的位置的next值
                j = next[j-1];
            }

            //相等的时候i和j都后移，代表前缀匹配成功
            if(needle[i] == needle[j]){
                //i循环后自动后移
                j++;
            }

            //最后赋值
            next[i] = j;
        }
    }

    int kmpMatch(vector<int> &next,string haystack,string needle){
        int i = 0;//原串标记
        int j = 0;//子串标记

        //条件为都小，因为子串走到头说明匹配到了
        while(i < haystack.size() &&j < needle.size()){
            if(haystack[i] == needle[j]){
                i++;
                j++;
            }
            else{
                //不相等要回退子串
                if(j != 0){
                    j = next[j-1];
                    //回退完进入下次比较
                    continue;
                }
                //此时回退不了了,主串只能后移重新匹配
                i++;
            }
        }

        //说明子串走完了，匹配成功
        if(j == needle.size()){
            //i为最后匹配字符的下一个，回退j那么长就是首次位置
            return i - j;
        }

        return -1;

    }
    int strStr(string haystack, string needle) {
        vector<int> next(needle.size());
        getNext(next,needle);

        return kmpMatch(next,haystack,needle);
    }
```

## 7.数组

### 74.搜索二维矩阵

```
解题思路:
此题思路比较简单，对第一列二分一次，找到最后一个小于目标元素的值，确定所在行，第二次二分在行内寻找目标
难点和细节：bottom的选择
```

***代码:***

```c++
bool binarySearch(vector<int>& matrix, int target) {
        int left = 0;
        int right = matrix.size() - 1;

        while(left <= right) {
            int mid = left + (right - left) / 2;

            if(matrix[mid] < target) {
                left = mid + 1;
            }
            else if(matrix[mid] > target) {
                right = mid - 1;
            }
            else {
                return true; 
            }
        }

        return false;
    }

    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int top = 0;
        int bottom = matrix.size() - 1;

        while(top <= bottom) {
            int mid = top + (bottom - top) / 2;

            if(matrix[mid][0] > target) {
                bottom = mid - 1;
            }
            //最后会走到这里，所以下面不能用top
            else if(matrix[mid][0] < target) {
                top = mid + 1;
            }
            else {
                return true;
            }
        }
		
        if(bottom < 0) {
            return false;
        }

        return binarySearch(matrix[bottom], target);
    }
```



### 33.搜索旋转排序数组

```
解题思路:
此题不太好想，首先要想二分一定要保证数组是有序的，那么我们的目的就是找到有序的数组或者说有序的范围
，直接进行二分，如果mid的值大于low的值说明从low到mid是递增的，如果mid值小于low说明mid以及它的右边是在旋转点右边，也是有序递增的,这道题的关键就是这里，旋转其实就是像右移动数组元素，那就想，总会有两部分有序，一部分是越界的在原数组中较大的元素跑到前面了，一部分可能是没越界的只是串到数组的后面了
所以这道题的解决关键就是，一直保证我们的二分是在一个有序范围内进行的
难点和细节：旋转的概念,二分进阶
```

***代码:***

```c++
    int search(vector<int>& nums, int target) {
        int low = 0, high = nums.size() - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] == target)
                return mid;
            //说明在旋转点左半部分
            else if (nums[mid] >= nums[low]) {
                if (target >= nums[low] && target < nums[mid])
                    high = mid - 1;
                else
                    low = mid + 1;
            }
            //说明在旋转点右半部分
            else {
                if (target <= nums[high] && target > nums[mid])
                    low = mid + 1;
                else
                    high = mid - 1;
            }
        }
        return -1;
    }
```

### 153.寻找旋转排序数组中的最小值

```
解题思路:
为旋转排序类的题，依然要理解旋转的概念(本题的关键是找到两个升序数组的分界)
新数组旋转点左面是比较大的元素，右边是比较小的数，这道题和搜索旋转排序数组不一样的点在于，要比较的值是末尾元素，也就是较小部分的最大元素
如果中间值比它大，说明在旋转点左侧的升序数组，所以左界限要右移
如果中间值比它小，说明在旋转点右侧的升序数组，所以右界限要左移，但此时注意右界限要到mid而不是mid-1
当相遇的时候就是找到了最小值，也就是分界的地方
难点和细节：旋转概念，边界条件
```

***代码:***

```c++
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size()-1;
        //开头是旋转过后，原来数组里大的
        while(left < right){
            int mid = left + (right - left)/2;
            //right为原来最大，比他大说明是旋转过后回到开头的元素
            if(nums[mid] > nums[right]){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }

        return nums[left];
    }
```

### 4.寻找两个正序数组的中位数

```
解题思路:
此题有两种常见写法，一种分割法，特别难理解，这里选择的是合并法，合并法也属于归并排序的一部分
先处理两个数组各为空的情况，处理完之后循环比较两个数组中的元素，小的添加进入临时数组中，然后处理剩余元素，最后看count的取余结果就行
空间复杂度是O(n+m),时间复杂度O(n+m)
难点和细节：合并思想
```

***代码：***

```c++
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        //合并写法
        int n = nums1.size();
        int m = nums2.size();
        vector<int> nums(n+m);
        //num1或num2等于0的情况
        if(n == 0){
            //求2的中位数
            if(m % 2 == 0){
                return (nums2[m/2] + nums2[m/2-1]) / 2.0;
            }
            else{
                return nums2[m/2]; 
            }
        }
        if(m == 0){
            //求1的中位数
            if(n % 2 == 0){
                return (nums1[n/2] + nums1[n/2-1]) / 2.0;
            }
            else{
                return nums1[n/2]; 
            }
        }
        //定义i,j,count
        int i = 0,j = 0,count = 0;
        //循环比较，剩余处理
        while(count != (m + n)){
            //剩余处理
            if(i == n){
                //nums1走完了
                while(j != m){
                    nums[count++] = nums2[j++];
                }
                break;
            }
            if(j == m){
                //nums2走完了
                while(i != n){
                    nums[count++] = nums1[i++];
                }
                break;
            }

            if(nums1[i] < nums2[j]){
                nums[count++] = nums1[i++];
            }
            else{
                nums[count++] = nums2[j++];
            }
        }
        //看count取余2
        if(count % 2 == 0){
            return (nums[count/2] + nums[count/2-1]) / 2.0;
        }
        else{
            return nums[count/2];
        }
    }
```



## 8.栈

### 394.字符串解码

```
解题思路:
借助辅助栈，主要的是两个变量，一个存储当前字符的重复次数，一个是当前的字符串
如果是数字就把重复次数拼上这个数字，如果是字母就加入到当前字符串中
碰到了左括号说明有要重复的数字了，把当前重复次数和当前字符串都压入栈里，然后清空，下次遇到重新计算
如果碰到右括号说明该添加结果了，加入当前栈里原字符串是aaa，重复次数是3，当前字符串是bc
那么实际的字符串应该是把栈里的一个原字串拼上3遍bc

容易理解的说：遇到数字说明接下来的字符要重复这个数字的次数了，一但遇到左括号就可以把现在有的字符串和接下来要重复的次数压栈里然后清空保存的次数和res，出现右括号就要把刚才存的拿出来然后拼上就好了

难点和细节：每个字符的处理，重复次数变量和res变量
```

***代码:***

```c++
string decodeString(string s) {
        stack<string> m_stack;
        //当前重复次数
        string multi;
        string res;

        int i = 0;
        while(i < s.size()){
            //如果是数字，更新muti
            if(s[i] >= '0' &&s[i] <= '9'){
                multi += s[i];
            }
            else if(s[i] >= 'a'&&s[i] <= 'z'){
                res += s[i];
            }
            //如果是[那么把当前重复次数和res 压入栈
            else if(s[i] == '['){
                m_stack.push(multi);
                m_stack.push(res);
                multi = "";
                res = "";
            }
            else if(s[i] == ']'){
                string tmpRes = m_stack.top();m_stack.pop();
                string tmpMulti = m_stack.top();m_stack.pop();
                int count = stoi(tmpMulti);
                string tmp = "";
                while(count--){
                    //例如当前res 为 bc，次数为2
                    //tmp += bc;  tmp = bcbc  tmpMulti = aaa
                    tmp += res;
                }
                //在加上原来的结果
                res = tmpRes + tmp;
            }
            i++;
        }

        return res;
        
    }
```

### 739.每日温度

```
解题思路:
此题使用了单调栈，也就是栈底到栈顶元素依次减小，栈底维护的永远是最大的元素
需要注意栈内保存的是元素的索引，而不是元素值，为了便于计算结果
首先从左到右依次元素入栈，入栈前比较栈顶元素的大小，如果比栈顶元素大就要弹出栈顶元素，然后计算结果存入结果数组，否则就压入栈中
难点和细节：单调栈,栈内记录索引
```

***代码:***

```c++
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        //索引栈
        stack<int> m_stack;
        //结果数组
        vector<int> res(temperatures.size(),0);

        //遍历数组，入栈
        for(int i = 0;i < temperatures.size();++i){
            //循环检查当前元素和栈顶元素的大小
            while(!m_stack.empty()&&temperatures[i] > temperatures[m_stack.top()]){
                //大于栈顶元素的大小，栈顶弹出,记录结果
                //因为栈里存的是原数组的索引,i-top就是距离的天数
                res[m_stack.top()] = i - m_stack.top();
                m_stack.pop();
            }

            //此时小于栈顶元素，或为空，压栈
            m_stack.push(i);
        }

        return res;
    }
```

### 84.柱状图中的最大矩形

```
解题思路:

此题和接雨水差不多，但比接雨水稍难，一般都有两种做法，双指针和单调栈，此题我使用单调栈思想
首先要明确这个矩形的面积怎么求，知道了问题就迎刃而解了
从每一个柱来看，找到左边第一个小于它的柱子，在找到右面第一个小于它的柱子，那么这个矩形的面积就是高×宽，也就是当前柱子的高度×(right-left-1)，理解了这个，问题就好办了
定义两个数组，左和右，代表每个元素的左边第一个小于它的元素，和右边第一个小于它的元素，注意初始化，左边数组的初始化值为-1，右边的为n，一会做说明
借助单调栈，当前元素小于栈顶元素说明栈顶元素不是要找的元素，那么出栈，直到栈为空或者找到第一个小于当前元素的，如果找到了那么left[i] = s.top(),然后入栈
但问题是没找到怎么办呢，说明左边没有比他小的了，那面积不就应该是当前元素的高度×(右边要找的元素到起点的距离-1)，
那如果初始化为0的话，会少算一个格，所以初始化为-1
右边同样道理依次借助单调栈找问题就解决了

难点和细节：单调栈，面积计算，左右数组初始化
```

***代码***

```c++
int largestRectangleArea(vector<int>& heights) {
        int resMax = 0;
        int n = heights.size();
        stack<int> m_stack;
        vector<int> left(n,-1);
        
        
        //找左边第一个比当前小的
        for(int i = 0;i < n ; ++i){
            //当前元素小于栈顶元素
            while(!m_stack.empty()&&heights[i] <= heights[m_stack.top()]){
                m_stack.pop();
            }

            //此时情况只剩栈为空，或者找到第一个比它小的元素
            if(!m_stack.empty()){
                //此时说明找到了第一个小于当前元素的
                left[i] = m_stack.top();
            }

            //压栈
            m_stack.push(i);
        }

        vector<int> right(n,n);
        stack<int>().swap(m_stack);//清空
        //找右边第一个比当前小的
        for(int i = n-1;i >= 0;--i){
            while(!m_stack.empty()&&heights[i] <= heights[m_stack.top()]){
                m_stack.pop();    
            }

            if(!m_stack.empty()){
                right[i] = m_stack.top();
            }

            m_stack.push(i);
        }

        //收集结果
        for(int i = 0;i < n;++i){
            resMax = max(resMax,(right[i]-left[i]-1)*heights[i]);
        }

        return resMax;
    }
```



## 9.堆

### 215.数组中的第K个最大元素

```
解题思路:
此题为堆排序的应用，面试官更倾向于让你自己实现一个堆排序，但由于刚学完五阶段，对堆排序比较熟悉，直接使用了c++里的优先队列实现
说说堆排序的实现吧，建立一个调整函数，拿到要调整节点的左子右子，与当前元素比较，不用交换就直接结束，用的话就要交换完递归调用要处理的节点
先把给定数组调整为大根堆，从n/2-1的地方往前调整，调整完大根堆之后，就要开始删除元素，注意循环条件
int i = nums.size() - 1; i >= nums.size() - k + 1; --i
这里的k是题目中的第几大，一直拿堆中最后一个元素与第一个元素交换，交换完调整，得到结果

难点和细节：堆排序的应用
```

***代码：***

```c++
int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> m_p;
        for(int i = 0; i < nums.size();++i){
            m_p.push(nums[i]);
        }

        int res = 0;
        while(k--){
            res = m_p.top();
            m_p.pop();
        }

        return res;
    }
```



### **295.数据流中的中位数**

```
解题思路:
此题思路上不难，但是第一次做的话很难想到这么精妙的设计
为了找一个数组中的中位数，我们可以把数组分成两部分，一部分是开头到中间的较小元素部分，一部分是中间到末尾的较大元素的部分，我们需要使用两个堆，一个大顶堆，一个小顶堆，大顶堆用来保存较小元素的部分，小顶堆用来保存较大元素的部分，这样堆顶的元素才是我们能利用的元素，如果元素个数为积数说明大顶堆的第一个元素就是结果，如果为偶数就是两个堆顶元素除2

解题步骤：
新来一个元素时，首先将其插入最大堆。
如果最大堆的大小超过了最小堆的大小+1，那么将最大堆的堆顶元素弹出并插入到最小堆。
如果最小堆的大小超过了最大堆，那么将最小堆的堆顶元素弹出并插入到最大堆。

难点和细节：双堆，分两部分放入各自堆
```

***代码:***

```c++
class MedianFinder {
public:
    MedianFinder(){
        
    }
    
    void addNum(int num) {
        if(maxHeap.empty() ||num <= maxHeap.top()){
            //元素小于最大堆堆顶的时候才入最大堆，否则入最小堆
            //确保小元素在最大堆，大元素在最小堆
            maxHeap.push(num);
        }
        else{
            minHeap.push(num);
        }

        //检查长度
        if(maxHeap.size() > minHeap.size() + 1){
            int topVal = maxHeap.top();
            maxHeap.pop();
            minHeap.push(topVal);
        }
        //这里不是+1的原因是因为，最大堆的元素数量要不就和最小堆相等，要不就是多一个
        else if(minHeap.size() > maxHeap.size()){
            int topVal = minHeap.top();
            minHeap.pop();
            maxHeap.push(topVal);
        }

    }
    
    double findMedian() {
        int n = maxHeap.size() + minHeap.size();
        if(n % 2 == 0){
            return (maxHeap.top() + minHeap.top()) / 2.0;
        }
        else{
            //最大堆多一个，所以中位数就是最大堆顶元素
            return maxHeap.top();
        }
    }
private:
    priority_queue<int> maxHeap;
    priority_queue<int,vector<int>,greater<int>> minHeap;
};
```

## 10.贪心

### 763.划分字母区间

```
解题思路:
使用贪心算法，首先算出每个字符的最后一次出现的位置，记录在哈希表里
定义start和end，从头遍历字符串，没遍历到一个字符就找到最后一次当前字符出现的位置，然后和end比较，如果比end大，更新end，说明区间可以扩张，如果直到遍历到end，都没有比它大的，说明这个区间内的所有元素都不会在end后面出现了，这就找到了一个字母区间，然后用start-end + 1拿到长度放入结果数组，start更新为end的下一个
难点和细节：贪心思想，更新end
```

***代码：***

```c++
vector<int> partitionLabels(string s) {
        vector<int> res;
        unordered_map<char,int> m_map;
        //记录每个字符最后一次出现的位置
        for(int i = 0;i < s.length();++i){
            m_map[s[i]] = i;
        }
        
        int start = 0,end = 0;
        for(int i = 0;i < s.length();++i){
            //比较当前的end和最后一次出现的字符的位置的大小
            //取最大的作为当前区间的最后一个
            end = max(end,m_map[s[i]]);

            if(i == end){
                res.push_back(end - start + 1);//收集结果
                start = i + 1;
            }
        }

        return res;
    }
```





## 11.动态规划

### 152.乘积最大子数组

```
解题思路:
此题说难不难，但是一时容易想不明白
正常如果做这道题没有负数和0的话，那么最大乘积一定是前一个元素×当前元素不断乘下去到最后一个
但是如果有了负数就不一样了，想想这种情况，4 -1 2 -2对应的最大乘积本来应该是 4 -1 2 -2但是由于有两个负数，本来到dp[2]的时候最大是2，乘-2是-4，但dpMin[2]最小是 -8，乘上-2就是16了，所以此时最大乘积dp数组，dp[3]的值应该是16
通过以上过程可知，我们光维护一个最大乘积数组还不够，还需一个最小乘积数组，然后正常处理
难点和细节：维护双dp数组
```

***代码：***

```c++
//官方有问题
    //结果是对的，但是官方问题最后一个样例过不了，官方题解也过不了，用java使用同样方法过了
    int maxProduct(vector<int>& nums) {
        vector<int> dpMax(nums.size()+1);
        vector<int> dpMin(nums.size()+1);

        dpMax[0] = dpMin[0] = 1;
        int resMax = INT_MIN;
        for(int i = 1;i <= nums.size();++i){
            //例如 4 -1 2 -2，出现俩负数，直接把最小-8 变成最大 16了
            dpMax[i] = max(nums[i-1],max(dpMax[i-1] * nums[i-1],dpMin[i-1] * nums[i-1]));
            dpMin[i] = min(nums[i-1],min(dpMax[i-1] * nums[i-1],dpMin[i-1] * nums[i-1]));
            resMax = max(resMax,dpMax[i]);
        }
        return resMax;
    }
```



### 32.最长有效括号

```
解题思路:
此题不能考虑太多，不要往复杂了想，我们只看右括号
动规五部曲：
1.dp[i]表示以第i个字符结尾的最长有效括号子串的长度
2.初始化的时候，所有元素初始化为0，这样的话，左括号的位置自动就是0了
3.递推公式可分为两种情况
	3.1当前为右括号，并且前一个字符是左括号，那么当前的最长就是当前匹配的两个字符的前一个字符的dp数值
	dp[i] = dp[i-2] + 2;//注意边界问题，如果i-2不存在直接置为2就行
	3.2当前括号为右括号，并且前一个字符是右括号，那么我们就要检查了，首先看看前一个元素dp的值，拿到一组连续有		效括号长度，然后往前推一组那么长，这样推了之后看看那个字符是不是左括号能不能和当前右括号匹配，如果能匹配，
	想一想，长度里应该是三部分，首先匹配到了一组该+2，然后垮了前一组那么长所以+dp[i-1],还有匹配到的那个左括
	号前面的最长所以+dp[i-dp[i-1]-1-1],加这个可能有点难理解，给个例子就懂了，()(()),最后一个括号的值是不是
	先匹配到第三个元素，左括号，+2,然后中间垮了一组()，加dp[i-1]也就是2,再加第二个元素也就是右括号,加上
	dp[5-2-1-1]也就是2，所以dp[5] = 6，这样就明白了吧
4.遍历顺序和打印，此题无需考虑
最后记得注意边界条件，加点if逻辑就行
难点和细节：只看右括号思想，长度匹配规则(递推公式)，边界条件处理
```

***代码:***

```c++
int longestValidParentheses(string s) {
        if(s.empty()) return 0;
        int maxRes = INT_MIN;
        //dp[i]表示以第i个字符结尾的最长有效括号子串的长度
        vector<int> dp(s.size(),0);
        //初始都为0，因为只看右括号，左括号的地方直接0就行
        for(int i = 0;i < s.size();++i){
            if(s[i] == ')'){
                //情况1.如果前一个字符是'('
                //说明匹配到一组，那么最大就是这组前面的最大+2
                if(i >= 1&&s[i-1] == '('){
                    if(i-2 >= 0) dp[i] = dp[i-2] + 2;
                    else dp[i] = 2;
                }
                //情况2.如果前一个字符是')'
                else if(i > 1&&s[i-1] == ')'){
                    //判断当前右括号往前推一组连续括号字串的那个元素是不是左括号
                    if((i - dp[i-1] -1) >= 0&&s[i - dp[i-1] - 1] == '('){
                        //那么最长就是那个找到的左括号的前一个dp的长度，加上跳过的长度，加上2
                        if((i - dp[i-1] - 2) >= 0){
                            dp[i] = dp[i -dp[i-1] - 2] + dp[i-1] + 2;
                        }
                        else{
                            //此时前面没有了，视为0
                            dp[i] = dp[i-1] + 2;
                        }
                    }
                    else{
                        //推一组前面没东西了
                        dp[i] = 0;
                    }
                }
            }

            maxRes = max(maxRes,dp[i]);
        }
        return maxRes;
    }
```



### **64.最小路径和**

```
解题思路:
本题为多维DP问题，题干上说只能向下和向右移动，那么刚开始递推公式就推出来了
dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1];
这里开了一个n+1*n+1的dp数组，主要是方便处理第一行和第一列的grid的元素
初始化dp数组，第一行和第一列的dp全为INT_MAX就行，因为我们第一行和第一列的状态其实都是grid[0][0]推出来的
那么就要注意把dp[0][1]和dp[1][0]的位置 置0，要不然会出现溢出
接下来就是正常遍历，根据递推公式然后求右下角的dp值即可
难点和细节：dp初始化
```

***代码：***

```c++
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));
        dp[0][1] = 0;
        dp[1][0] = 0;
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1];
            }
        }
        return dp[m][n];
    }
```



### 5.最长回文子串

```
解题思路:
多维dp问题，此题要分三种情况处理
先定义二维bool数组，dp[i][j]的意思是下标i到下标j 是否是回文串
定义最大长度和起始下标，为了最后substr准备
1.子串长度为1的是dp[i][i]全初始化为true
2.子串长度为2的如果s[i]和s[i+1]相等初始化为true，然后更新最大长度为2，开始下标为i
3.子串长度为3，int j = i + len - 1; j为长度为len的子串末尾，如果末尾和开头相等，那么只需要看看中间是不是回文串就可以了，如果是更新长度和起始下标，dp[i][j]为true

把情况拆开的好处是情况3的时候不怕越界，不用处理越界问题

难点和细节：情况拆分，长度3情况处理(dp[i+1][j-1])
```

***代码：***

```c++
string longestPalindrome(string s) {
        int n = s.size();
        if(n < 2) return s;

        vector<vector<bool>> dp(n,vector<bool>(n,false));

        int maxLen = 1;
        int startIndex = 0;

        //长度为1的
        for(int i = 0;i < n;++i){
            dp[i][i] = true;
        }

        //长度为2的子串
        for(int i = 0;i < n-1;++i){
            if(s[i] == s[i+1]){
                dp[i][i+1] = true;
                maxLen = 2;
                startIndex = i;
            }
        }

        for(int len = 3;len <= n;len++){
            //长度为len的有n-len+1个，所以挨个判断
            for(int i = 0;i < n-len+1;++i){
                //每个长度为len的子串的末尾
                int j = i + len - 1;       
                //首尾相同，中间还是回文
                if(s[i] == s[j]&&dp[i+1][j-1]){
                    dp[i][j] = true;
                    maxLen = len;
                    startIndex = i;
                }          
            }
        }


        return s.substr(startIndex,maxLen);
    }
```



## 12.代码随想录复习二刷

### 12.1 数组

#### 704.二分查找

```
此题没有什么难的，但是有一个重要知识点，就是区间判断
如果你定义的是左闭右闭区间，也就是left = 0，right = size-1这种，那么循环条件就应该是left <= right
因为当left==right的时候这个元素在你想要的区间里，是有意义的

但如果定义的是左闭右开区间，也就是left = 0，right = size，那么循环条件就应该是left < right
因为当left == right的时候这个元素相当于在右边界，不是你想要的范围，所以不能要
```



#### 27.移除元素

```
解题思路:
简单方法就是暴力，两边循环，然后覆盖
使用双指针可以优化时间，慢指针指向当前数组的最后一个位置，快指针指向的是原数组，起到一个遍历作用
快指针指向的元素如果等于val就++跳过，如果不等于就覆盖当前数组的最后一个位置，然后slow++fast++
这里可以用循环变量代替快指针

难点和细节：双指针
```

**代码:**

```c++
    int removeElement(vector<int>& nums, int val) {
        if(nums.size() == 0) return 0;

        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
```



#### 977.有序数组的平方

```
解题思路:
本题最简单方法就是排序，然后遍历求平方
此处使用双指针，左右指针
需要注意，我们往数组里装元素的时候是倒着装的，也就是说确保大的在后面，因为你不能先把小的放前面，没有办法先知道谁比谁小，右指针一定是原数组最大的，左是原数组最小的，但是由于负数的存在，最小的也可能会变成最大的，所以我们要比大值放后面，再就没有难的了

难点和细节：先找大的放后面，双指针
```

***代码：***

```c++
vector<int> sortedSquares(vector<int>& nums) {
        vector<int> res(nums.size(),0);
        int left = 0;
        int right = nums.size()-1;
        int index = nums.size()-1;
        while(left <= right){
            int leftVal = nums[left] * nums[left];
            int rightVal = nums[right] * nums[right];
            if(leftVal > rightVal){
                res[index] = leftVal;
                --index;
                ++left;
            }
            else{
                res[index] = rightVal;
                --index;
                --right;
            }
        }

        return res;
    }
```

#### 209.长度最小的子数组

```
解题思路:
滑动窗口经典应用，属于简单的滑动窗口
当窗口内的元素值大于等于目标值的时候就先收集结果，减去窗口开头元素值，开头后移缩小区间，直到数组末尾
当窗口内元素值小于目标值时，窗口末尾后移然后窗口内的值加上末尾值继续判断
需要注意的是，当加上末尾值的时候要进行>=target值的判断，而且切记是个while循环，因为可能新加上的数特别大，导致前面的区间可以一直缩减

难点和细节:滑动窗口，循环判断
```

***代码:***

```c++
    int minSubArrayLen(int target, vector<int>& nums) {
        //滑动窗口
        int n = nums.size();
        int minLen = INT_MAX;
        
        int start = 0,end = 0;

        int window = 0;
        while(end < n){
            window += nums[end];
            while(window >= target){
                //收集结果
                minLen = min(minLen, end - start + 1);
                //减小窗口
                window -= nums[start];
                //缩小区间
                start++;
            }
            end++;
        }

        //防止最后了还没找到匹配的结果而返回INT_MAX
        return minLen == INT_MAX ? 0 : minLen;
    }
```

#### 59.螺旋矩阵Ⅱ

```
解题思路:
这道题并不难，和螺旋矩阵1的思想一样，就是比1需要一个过程值来填充矩阵
此类题只需要掌握四个界限，上下左右，然后每走完一次就调整界限，思想不难，但是写代码较为重复
先从左到右，然后缩减上界，然后上到下，缩减右界，然后右到左，缩减下界，然后下到上，缩减左界
缩减之后记得进行范围判断，否则出不去循环

难点和细节:条件的掌握
```

***代码:***

```c++
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> result(n,vector<int>(n));
        int u = 0, d = n-1;
        int l = 0, r = n-1;

        int val = 1;
        int maxVal = n*n;
        while(true){
            //左到右
            for(int i = l;i <= r;++i){
                result[u][i] = val;
                if(++val > maxVal) break;
            }

            //上界下压
            if(++u > d||val > maxVal) break;

            //上到下
            for(int i = u;i <= d;++i){
                result[i][r] = val;
                if(++val > maxVal) break;
            }

            //右界左压
            if(--r < l||val > maxVal) break;

            //右到左
            for(int i = r;i >= l;--i){
                result[d][i] = val;
                if(++val > maxVal) break;
            }

            //下界上压
            if(--d < u||val > maxVal) break;

            //下到上
            for(int i = d;i >= u;--i){
                result[i][l] = val;
                if(++val > maxVal) break;
            }

            //左界右压
            if(++l > r||val > maxVal) break;
        }

        return result;
    }
```

### 12.2 链表

#### 203.移除链表元素

```
解题思路:
算是虚拟头节点的使用的问题
此题没什么要点，无非注意遍历当前节点的时候从dummy开始，然后删除节点的时候看下一个的值，如果等于要删除的值
那么先保存下一个，然后把当前节点连接上下一个的下一个，然后释放中间节点内存就行

难点和细节:虚拟头使用
```

***代码:***

```c++
    ListNode* removeElements(ListNode* head, int val) {
        if(!head) return nullptr;
        ListNode *dummy = new ListNode(0);
        dummy->next = head;
        ListNode *cur = dummy;
        ListNode *tmp = nullptr;
        while(cur->next){
            if(cur->next->val == val){
                tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
                tmp = nullptr;
            }
            else{
                cur = cur->next;
            }
        }
        return dummy->next;
    }
```

#### 707.设计链表

```
解题思路:
此题是纯数据结构问题，设计数据结构
关键点是在类里写一个虚拟头，然后搞一个size用来作为判断条件
接下来的函数实现就比较简单了

难点和细节:数据结构设计
```

***代码:***

```c++
struct ListNode{
    int val;
    struct ListNode *next;
    ListNode():val(0),next(nullptr){}
    ListNode(int n):val(n),next(nullptr){}
    ListNode(int n,ListNode *p):val(n),next(new ListNode(p->val)){}
};

// @lc code=start
class MyLinkedList {
public:
    MyLinkedList():dummy(new ListNode(0)),listSize(0){

    }
    
    int get(int index) {
        if(index < 0||index > listSize-1) return -1;

        ListNode *cur = dummy->next;
        while(index--){
            cur = cur->next;
        }

        return cur->val;
    }
    
    void addAtHead(int val) {
        ListNode *node = new ListNode(val);
        
        node->next = dummy->next;
        dummy->next = node;
        listSize++;
    }
    
    void addAtTail(int val) {
        ListNode *node = new ListNode(val);
        ListNode *cur = dummy;

        //找最后一个节点
        while(cur->next){
            cur = cur->next;
        }

        //此时为最后
        cur->next = node;
        listSize++;
    }
    
    void addAtIndex(int index, int val) {
        //此时index可以等于listSize，因为从dummy开始走，
        //走listSize那么长就是到最后一个
       if(index > listSize) return;

       ListNode *node = new ListNode(val);
       ListNode *cur = dummy;

       while(index--){
            cur = cur->next;
       } 
       //此时cur的下一个元素就是应该插入的位置
       node->next = cur->next;
       cur->next = node;
       listSize++;
    }
    
    void deleteAtIndex(int index) {
        if(index < 0||index > listSize-1) return;

        ListNode *cur = dummy;

        while(index --){
            cur = cur->next;
        }
        //此时下一个元素是要删除的元素
        ListNode *tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        tmp = nullptr;
        listSize--;
    }
private:
    ListNode *dummy;
    int listSize;
};
```



#### 206.反转链表

```
解题思路:
不讲解迭代法了，讲讲递归，不太好理解
就拿1，2，3，4，5来说，head->next不存了，所以返回一个五，node的值为5
5这轮不看了，看4这轮，由于上一轮同样返回node，所以node的值还是5也就是我们保存的未来的头节点
我们让head->next->next = head;距离就是4的下一个也就是5，5的next = head也就是5的next = 4，此时循环指向了，我们再把head->next = nullptr,让它断开就完成了

难点和细节:链表理解
```

***代码:***

```c++
ListNode* reverseList(ListNode* head) {
        //普通迭代实现
        // ListNode *pre = nullptr;
        // ListNode *cur = head;
        // ListNode *tmp;
        // while(cur){
        //     tmp = cur->next;
        //     cur->next = pre;
        //     pre = cur;

        //     cur = tmp;
        // }

        // return pre;

        // 递归实现
        if(!head||!head->next){
            return head;
        }

        ListNode *node = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;

        return node;

        //还有头插入法，需要额外空间，但比较简单，这里不给出了
    }
```

#### 24.两两交换链表中的节点

```
解题思路:
此题考查对链表的操作，需要捋清思路
创建虚拟头节点和遍历节点
首先保存当前节点的下一个节点还有下下下个节点，因为做连接操作的时候会丢节点
然后开始三步操作，把当前节点的next连到下下个节点上
下下个节点的next连到保存的tmp1节点
tmp1的next连到tmp2身上
最后返回虚拟头的下一个

难点和细节:链表理解
```

***代码:***

```c++
    ListNode* swapPairs(ListNode* head) {
        if(!head) return nullptr;
        ListNode *dummy = new ListNode(0);
        dummy->next = head;

        ListNode *cur = dummy;
        while(cur->next &&cur->next->next){
            //保存会丢失的节点
            ListNode *tmp1 = cur->next;
            ListNode *tmp2 = cur->next->next->next;

            cur->next = cur->next->next;
            cur->next->next = tmp1;
            tmp1->next = tmp2;

            cur = cur->next->next;
        }
        
        return dummy->next;
    }
```

#### 19.删除链表的倒数第n个节点

```
解题思路:
此题算是技巧题，难点在于如何找到要删除的节点，快慢指针的经典应用
定义快慢指针指向虚拟头节点
让快指针先走n+1步，然后快慢指针同时走直到快指针为nullptr为止
此时slow指针的next就是要删除的节点，直接删除即可

难点和细节:快指针先走n+1步
```

```c++
还有一种解法使用递归计数，这里直接给出代码
    int removeNthFromEndHelper(ListNode* head, int n){
        if(!head) return 0;

        int count = 1 + removeNthFromEndHelper(head->next, n);

        if(count == n + 1){
            ListNode* tmp = head->next;
            head->next = head->next->next;
            delete tmp;

        }

        return count;
    }
当计数到n+1的时候也说明下一个节点就是要删除的节点，直接删除即可
```

***代码:***

```c++
public:
     ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *dummy = new ListNode(0);
        dummy->next = head;
        ListNode *slow = dummy,*fast = dummy;

        int step = n + 1;
        while(step-- && fast){
            fast = fast->next;
        }

        while(fast){
            fast = fast->next;
            slow = slow->next;
        }
        //此时slow的下一个是要删除的节点
        ListNode *tmp = slow->next;
        slow->next = slow->next->next;
        delete tmp;

        return dummy->next;
    }
```

#### 160.相交链表

```
解题思路:
此题一般有两种解法，一种是先算出两条链表的长度，看看谁长，然后相减，让长的那个先走长的步数，然后两个链表齐头并进走到相遇，即为所求
另一种是，两个节点同时走，当走到头的时候掉头到另一个链表的头在开始走，直到相遇的点即为所求点，能确保路程一样
```

***代码1:***

```c++
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int len_a = 0;
        int len_b = 0;

        ListNode *cur = headA;

        while(cur){
            len_a ++;
            cur = cur->next;
        }

        cur = headB;
        while(cur){
            len_b++;
            cur = cur->next;
        }

        ListNode *curA = headA;
        ListNode *curB = headB;
        int step = 0;
        if(len_a > len_b){
            step = len_a - len_b;
            while(step--){
                curA = curA->next;
            }

        }
        else{
            step = len_b - len_a;
            while(step--){
                curB = curB->next;
            }
        }


        while(curA != curB){
            curA = curA->next;
            curB = curB->next;
        }

        return curA;
    }
```

***代码2:***

```c++
        if(headA == nullptr||headB == nullptr){
            return nullptr;
        }
        ListNode* a = headA;
        ListNode* b = headB;
        while(a != b){
            if(a != nullptr){
                a = a->next;
            }
            else{
                a = headB;
            }
            if(b != nullptr){
                b = b->next;
            }
            else{
                b = headA;
            }     
        }
        return a;
```

#### 142.环形链表

```
解题思路:
此题也是技巧题，背下来思路，之后就不会忘了
定义快慢指针指向头部节点，外面一层循环，条件是fast存在并且fast->next存在
slow走一步，fast走两步
在循环内走完判断，如果fast == slow，那么2(x+y) = x+y+z+y不理解记得看代码随想录
定义一个指针到头节点，然后慢指针从当前位置，另一个指针从头开始走，相遇即为入口节点
返回即可

难点和细节:技巧，(另外看看代码书写，比较精简)
```

***代码:***

```c++
ListNode *detectCycle(ListNode *head) {
        if(!head) return nullptr;
        ListNode *fast = head;
        ListNode *slow = head;

        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;

            if(slow == fast){
                ListNode *cur = head;
                while(cur != slow){
                    cur = cur->next;
                    slow = slow->next;
                }
                return cur;
            }
        }

        return nullptr;
    }
```



### 12.3 哈希表

#### 242.有效字母异位词

```
解题思路:
两种解法，一种是排序两个string，判断相等，无序额外空间
一种是哈希思想，用unordered_map或者开个26长度的数组映射也行
先遍历s，存储对应元素出现的次数，然后再遍历t，--哈希表里的对应元素的值，最后遍历数组看看有没有不等于0的元素，则为false

难点和细节:哈希
```

***代码:***

```c++
bool isAnagram(string s, string t) {
        int arr[26];
        for(char c:s){
            arr[c - 'a']++;
        }

        for(char c:t){
            //先--
            arr[c - 'a']--;
        }

        for(int i = 0;i<26;++i){
            if(arr[i] != 0) return false;
        }
        return true;
    }
```

#### 349.两个数组的交集

```
不做过多讲解，看代码即可
注意一点，set可以直接用来构造vector
```

***代码:***

```c++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        
        unordered_set<int> set;
        unordered_set<int> tmp;

        for(int i:nums1){
            set.insert(i);
        }

        for(int i:nums2){
            if(set.find(i) != set.end())
                tmp.insert(i);
        }

        return vector<int>(tmp.begin(),tmp.end());

    }
```

#### 1.两数之和

```
解题思路:
这题也是两种解法，1暴力，找到一个元素之后再进行遍历有没有相加得target
2.哈希，精髓其实是把前面出现的记下来，这样后面遍历到其他元素得时候就能知道以前出没出现过可以匹配得元素了

难点和细节:哈希存值和索引
```

***代码:***

```c++
vector<int> twoSum(vector<int>& nums, int target) {
        //哈希表存的是值和索引
        unordered_map<int,int> map;

        for(int i = 0;i < nums.size();++i){
            auto ite = map.find(target - nums[i]);
            if(ite != map.end()){           
                return {i,ite->second};
            }
            //没找到，添加map
            map.insert(pair<int,int>(nums[i],i));
        }
        
        return {};
    }
```

#### 454.四数相加Ⅱ

```
解题思路:
此题算是比较有意思的题目，第一个想法是暴力，但那样会四重循环
考虑哈希表，分组计算，把时间复杂度砍半，O(n^2)
定义哈希表，用来存储前两组元素的两数之和还有出现次数(这个次数用来实现不同组合)
双层for遍历前两个数组相加和然后统计次数，再次双层for遍历后两个数组看能不能在map中找到-(nums3[i] + nums4[j])
能找到注意不能单纯++，因为会漏解，这是一种组合，要加上次数

难点和细节:分组，加次数
```

***代码：***

```c++
int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        int res = 0;
        //存放的是A和B数组两数之和的值和出现次数
        unordered_map<int,int> map;

        //遍历统计A和B两数之和的值和次数
        for(int i = 0;i < nums1.size();++i){
            for(int j = 0;j < nums1.size();j++){
                map[nums1[i] + nums2[j]] ++;
            }
        }

        //计算0-(c+d)在map里是否出现过，如果出现++res

        for(int i = 0;i < nums3.size();++i){
            for(int j = 0;j < nums3.size();++j){
                if(map.find(-(nums3[i] + nums4[j])) != map.end()){
                    //这个地方要注意
                    res += map[-(nums3[i] + nums4[j])];
                }
            }
        }

        return res;

    }
```



#### 383.赎金信

```
此题和有效字母异位词逻辑很像，不做过多说明
```

***代码:***

```c++
bool canConstruct(string ransomNote, string magazine) {
        int arr[26] = {0};
        //统计b中出现字符对应次数
        for(char c:magazine){
            arr[c - 'a']++;
        }

        for(char c:ransomNote){
            arr[c - 'a']--;
            if(arr[c - 'a'] < 0){
                return false;
            }
        }

        return true;
    }
```



#### 15.三数之和

```
解题思路:
最开始想到一种解法，回溯暴搜然后去重，但是超时了，详见代码1

正常解法是双(三)指针思路，题意是三个数求和等于0，那么我们的操作就是要寻找这三个数
首先需要排序，后面会知道有什么作用
首先外层循环变量i代表第一个数，进行剪枝处理，因为说求和得0，那么如果这个数本身就大于0了直接返回就行，因为排序后得数组后面全是比它大的
然后进行去重，注意一定是nums[i] == nums[i-1] continue;如果是nums[i] == nums[i+1] 会漏掉例如 -1 -1 2 0这种解，并且我们的left其实等于i+1，你拿i+1判断不是相当与判断left和i想等与否了

然后定义left(i+1)和right(size-1)代表其他两个数，循环条件是right > left
有三种条件要判断，首先第一个数是不动的，那么如果三数之和 > 0说明取大了，right--
三数之和 < 0说明取小了left++
否则说明找到了结果，添加到res中，此时添加完之后进行去重，只需要循环判断left右侧和right左侧有没有相等的，然后做left++，right--即可
最后找到了一个结果left和right都不能在取了，都缩减区间

难点和细节:三个指针，去重逻辑
```

***代码1:***

```c++
	vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int>& nums,int startIndex,int sum){
        if(path.size() == 3&&sum == 0){
            res.push_back(path);
            return;
        }

        int tmp = sum;
        for(int i = startIndex;i < nums.size();++i){
            if(i > startIndex && nums[i] == nums[i-1]) continue;
            path.push_back(nums[i]);
            tmp += nums[i];
            backTracking(nums,i + 1,tmp);
            tmp -= nums[i];
            path.pop_back();
        }

        return;
    }

    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        backTracking(nums,0,0);
        return res;
    }
```

***代码2:***

```c++
vector<vector<int>> threeSum(vector<int>& nums){
        vector<vector<int>> res;
        sort(nums.begin(),nums.end());
        for(int i = 0;i < nums.size();++i){
            //选定a值,如果第一个就大于0后面加一起永远不可能等于0
            if(nums[i] > 0) return res;

            //去重a
            if(i > 0&&nums[i] == nums[i-1]) continue;

            //定义b和c
            int left = i + 1;
            int right = nums.size()-1;
            while(right > left){
                //三种条件
                if(nums[i] + nums[left] + nums[right] > 0){
                    //取大了，right--
                    right--;
                }
                else if(nums[i] + nums[left] + nums[right] < 0){
                    //小了
                    left++;
                }
                else{
                    //收集结果
                    res.push_back({nums[i],nums[left],nums[right]});

                    //对b和c进行去重
                    while(right > left&&nums[left] == nums[left+1]) left++;
                    while(right > left&&nums[right] == nums[right-1]) right--;
                    
                    //收集完b和c之后这俩数不能要了，缩减区间
                    left++;
                    right--;
                }
            }
        }

        return res;
    }
```



#### 18.四数之和

```
解题思路:
三数会了四数不难，此题三数变成了四数，并且不再是相加得0，而是target
在三数的基础上又套了一层循环，但是注意剪枝操作和去重逻辑有点不同，有大数相加的地方还要注意溢出问题，直接开longlong一劳永逸

最外层剪枝操作注意，如果当前数大于target并且当前数大于等于0才可以break，如果紧紧当前数大于target会有如下这种情况，-4 -1 -5 0,target = -5，可以看到-4大于-5，但是不能break，只有确保nums[i] >= 0才能退出，去重逻辑一样

第二层得剪枝操作同理，只不过把一个数变成了两个数，nums[i] + nums[j]，去重也是一样的逻辑
剩下逻辑与三数之和一样

难点和细节:剪枝的改变，数据溢出，四指针
```

***代码:***

```c++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(),nums.end());
        for(int i = 0;i < nums.size();++i){
            //开始选择第一个数
            //剪枝操作
            if(nums[i] > target&&nums[i] >= 0) break;

            //第一个数去重
            if(i > 0&&nums[i] == nums[i-1]) continue;
            for(int j = i+1;j < nums.size();++j){
                //选择第二个数
                //剪枝和去重
                if(nums[i]+nums[j] > target&&nums[i] + nums[j] >= 0) break;

                if(j > i+1&&nums[j] == nums[j-1]) continue;

                //开始三数之和逻辑
                int left = j+1;
                int right = nums.size()-1;
                while(right > left){
                    //开始条件判断
                    
                    if((long long)nums[i] + nums[j] + nums[left] + nums[right] > target){
                        right--;
                    }
                    else if((long long)nums[i] + nums[j] + nums[left] + nums[right] < target){
                        left++;
                    }
                    else{
                        //收集结果
                        res.push_back(vector<int>{nums[i], nums[j], nums[left], nums[right]});

                        //去重
                        while(right > left&&nums[left] == nums[left+1]) left++;
                        while(right > left&&nums[right] == nums[right-1]) right--;

                        //收集完left和right不能再要，缩减区间
                        left++;
                        right--;
                    }
                }
            }
        }
        return res;
    }
```



### 12.4 字符串

#### 344.反转字符串

```
过于简单不做讲解
```

***代码:***

```c++
void reverseString(vector<char>& s) {
        int left = 0;
        int right = s.size()-1;
        while(right > left){
            swap(s[left],s[right]);
            left++;
            right--;
        }
    }
```



#### 541.反转字符Ⅱ

```
无需过细讲解，但是有点恶心
通过循环变量，i += (2*k)实现每2k个字符，这样的话只需要考虑反转
每次进入循环线判断剩余字符还够不够k个，不够全反转
够的话只需要反转开头+i，到开头+i+k的位置
```

***代码:***

```c++
string reverseStr(string s, int k) {
        for(int i = 0;i < s.size();i += (2 * k)){
            if(s.size() - i < k){
                //剩余字符小于k个，全部反转
                reverse(s.begin() + i, s.end());
                break;
            }

            //否则反转前k个字符
            reverse(s.begin() + i,s.begin() + i + k);
        }
        return s;
    }
```



#### 151.反转字符串中的单词

```
解题思路:
此题有两个关键，移除空白函数和反转单词函数
先说移除空白，定义双指针,一个指向单词的slow，一个用来越过空白的i
如果是while循环如果是空白&&<len就++i，出循环了记得判断一下i超没超出长度，如果超出了就break
否则找到第一个字母，让slow指向单词首字母，i继续移动到下一个空格，截取拼接到新字符串里
然后末尾加上空格

循环外面要判断末尾是不是空格并且串是不是空，如果是空格就要popback移除

反转单词函数里，我们需要先整体反转，然后再逐单词内部反转就能拿到反转单词的结果
同样定义双指针找单词越过空格，然后内部反转，最终返回即可

难点和细节:空白处理，反转整体再反转内部思想，边界处理
```

***代码:***

```c++
string remove_space(string s) {
        int len = s.length();
        string res;
        int slow = 0;
        
        for(int i = 0;i < s.size();){
            while(i < len&&s[i] == ' ') i++;
            if(i == len) break;

            //此时找到一个字母,slow移动
            slow = i;

            //找到下一个空格
            while(i < len&&s[i] != ' ') i++;

            //截取拼接到res里
            res += s.substr(slow, i - slow);
            //在拼个空格
            res += ' ';
        }

        // 移除末尾多余的空格
        if (!res.empty() && res.back() == ' ') {
            res.pop_back();
        }

        return res;
    }

    string reverseWords(string s) {
        // 移除首尾和多余空格
        s = remove_space(s);
        // 先整体反转
        reverse(s.begin(), s.end());

        int start = 0;
        for (int end = 0; end <= s.size(); ++end) {
            // end为空格或者为末尾，可以单词反转了
            if (end == s.size() || s[end] == ' ') {
                reverse(s.begin() + start, s.begin() + end);
                // 中间至多一个空白，end在的地方就是空白，所以+1即可
                start = end + 1;
            }
        }
        return s;
    }
```



#### 459.重复的子串

```
解题思路:
此题使用kmp来做，kmp这里不再赘述
主要理解字符串长度如果能整除(长度-最后一位的next)就返回true
例如abab，最后一位为2，4-2等于2，4能整除2则返回true

难点和细节:公式理解，KMP
```

***代码：***

```c++
    void getNext(vector<int>& next,string s){
        next[0] = 0;
        //定义前缀
        int j = 0; 

        for(int i = 1;i < s.size();++i){
            //不相等要回退
            while(j > 0&&s[j] != s[i]){
                j = next[j-1];
            }
            //相等都++
            if(s[j] == s[i]) j++;

            //最后要给next赋值
            next[i] = j;
        }
    }

    bool repeatedSubstringPattern(string s) {
        if(s.size() == 0) return false;
        vector<int> next(s.size());
        getNext(next,s);
        int len = s.size();
        if(next[len - 1] != 0&&len %(len - (next[len -1])) == 0){
            return true;
        }

        return false;
    }
```



### 12.5 栈和队列

#### 232.用栈实现队列

```
此题没有难度，但是要讲一下这个复用逻辑
压栈的时候我们直接压入栈1
出栈的时候我们先看看栈2是不是空，如果是空说明可以把栈1的元素全都压进去，这样栈顶元素就是先进去的
说说为什么要判断2空，如果不是空你还往里压入的话过去先进去的元素就不会先出去了，所以要确保先进去的元素全都出去了之后在压，这样peek函数可以直接复用pop代码
```

***代码:***

```c++
class MyQueue {
public:
    MyQueue() {

    }
    
    void push(int x) {
        //压栈直接压
        m_st1.push(x);
    }
    
    int pop() {
        //倒到另一个栈里
        //只有为空的时候才压
        if(m_st2.empty()){
            while(!m_st1.empty()){
                m_st2.push(m_st1.top());
                m_st1.pop();
            }
        }
        
        int val = m_st2.top();
        m_st2.pop();
        return val;
    }
    
    int peek() {
        //复用一下
        int res = this->pop();
        m_st2.push(res);
        return res;
    }
    
    bool empty() {
        return m_st1.empty()&&m_st2.empty();
    }
private:
    stack<int> m_st1;
    stack<int> m_st2;
};
```



#### 225.队列实现栈

```
简单题不用讲
可以双队列实现，但是没必要，单队列足够了
```

***代码:***

```c++
class MyStack {
public:

    queue<int> q1;
    //queue<int> qe2;
    MyStack() {
        
    }
    
    void push(int x) {
        q1.push(x);
    }
    
    int pop() {
        int count = q1.size()-1;
        while(count--){
            int val = q1.front();
            q1.pop();
            q1.push(val);
        }
        //到栈顶元素了
        int res = q1.front();
        q1.pop();
        return res;
    }
    
    int top() {
        return q1.back();
    }
    
    bool empty() {
        return q1.empty();
    }
};
```



#### 20.有效的括号

```
解题思路:
此题难度为easy但是不要上来就写，要清楚三种false情况
第一种，全都匹配完了栈里还有左括号
第二种，栈都为空了还有右括号要匹配
第三种，栈虽然有值，但是左右括号不匹配

代码精髓在于，遇到左括号入栈的不是左括号而是对应的右括号，这样到时候匹配的时候直接用==就能判断，不用复杂的if逻辑了
如果是右括号的时候就进行相应情况的判断，在else里就可以把第2，3种情况判断了
出循环在判断第一种情况

难点和细节:三种情况梳理，入右括号
```

***代码：***

```c++
bool isValid(string s) {
        //不是右括号就入栈
        int len = s.length();
        stack<char> m_st;
        for(int i = 0;i < len;++i){
            //遇到左括号入相应的右括号
            if(s[i] == '(') m_st.push(')');
            else if(s[i] == '[') m_st.push(']');
            else if(s[i] == '{') m_st.push('}');
            else{
                //匹配右括号之前如果栈空了或者和栈顶元素不相等就失败
                if(m_st.empty()||s[i] != m_st.top()) return false;
                //右括号的时候，要和栈顶元素匹配
                m_st.pop();
            }
        }

        //循环退出了栈还不为空就失败
        if(!m_st.empty()) return false;

        return true;
    }
```



#### 1047.删除字符串中的所有相邻重复项

```
简单题无需讲解
有一个细节要注意，就是和栈内元素进行比较的时候要确认栈不为空，否则编译不过
```

***代码:***

```c++
string removeDuplicates(string s) {
        stack<char> st;
        //入栈同时匹配
        for(int i = 0;i < s.length();++i){
            if(!st.empty()&&s[i] == st.top()){
                st.pop();
            }
            else{
                st.push(s[i]);
            }
        }
        
        //装回字符串
        string res;
        while(!st.empty()){
            res.push_back(st.top());
            st.pop();
        }

        reverse(res.begin(),res.end());
        return res;
    }
```



#### 150.逆波兰表达式求值

```
解题思路:
此题虽然是medium，但是难度不高
遍历字符串，遇到数字直接入栈，为了方便这里的栈内元素直接存int
遇到符号就弹出栈顶两个元素进行运算，运算完重新入栈
这样最后栈内剩下的元素就是我们想要的元素的值

难点和细节:逆波兰，栈
```

***代码:***

```c++
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for(string c:tokens){
            //遇到数字入栈
            if(c != "+"&&c != "-"&&c != "*"&&c != "/"){
                st.push(stoi(c));
            }
            else{
                //遇到符号出栈栈顶两个元素
                int tmp = 0;
                int a = st.top();st.pop();
                int b = st.top();st.pop();
                //进行运算
                if(c == "+"){
                    tmp = a+b;
                }
                else if(c == "-"){
                    //这里记得顺序
                    tmp = b-a;
                }
                else if(c == "*"){
                    tmp = a*b;
                }
                else if(c == "/"){
                    tmp = b/a;
                }
                //重新入栈
                st.push(tmp);
            }

        }
        //最后结果就是栈顶元素
        return st.top();
    }
```



#### 239.滑动窗口的最大值

```
解题思路:
比较经典的滑动窗口题目，使用双端队列来解题
维护的双端队列里的元素是单调递减的，但是要注意我们队列里的元素是下标，不是值，为了到时候移除窗口外的元素

明确入队的条件，只要当前元素大于末尾元素就要弹出末尾元素(注意空队列)
明确收集结果的条件，i >= k-1以后都要收集，直接添加队首元素就行
如何移除窗口外的元素，只需要在循环最开始，判断队首元素的下标是否<= i-k

难点和细节:滑动窗口，存下标不存值
```

***代码：***

```c++
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        //队列里的元素单调递减
        deque<int> q;//q里存下标

        for(int i = 0;i < nums.size();++i){
            //移除窗口外的元素(通过下标)
            if(!q.empty()&&q.front() <= i-k){
                q.pop_front();
            }
            //入队条件
            while(!q.empty()&&nums[i] > nums[q.back()]){
                q.pop_back();
            }
            //入队元素
            q.push_back(i);
            //i >= k-1以后才统计
            if(i >= k-1){
                res.push_back(nums[q.front()]);
            }
        }

        return res;
    }
```



#### 347.前K个高频元素

```
解题思路:
此题是堆的应用，而C++中的堆就可以使用优先队列，默认大顶堆，如下我的代码比较简单，也可以自己定义自己的排序规则(lambda或者仿函数)，此题大堆小堆都能做
首先统计每个元素出现的次数，使用map或者hash随意
把对应的元素和次数插入到堆中，但是注意，我们保存的时候用的是元素:次数
插入的时候要用次数:元素，因为C++中优先队列默认对pair的比较是根据第一个值的大小进行比较的，相等在比较第二个
之后循环取前k个就可以了

难点和细节:堆
```

***代码:***

```c++
    vector<int> topKFrequent(vector<int>& nums, int k) {
        vector<int> res;
        //统计次数
        map<int,int> m_map;
        for(int i:nums){
            //元素和次数
            m_map[i]++;
        }
        //插入对应次数到堆里
        priority_queue<pair<int,int>> m_p;
        for(auto p:m_map){
            //先存次数
            m_p.push({p.second,p.first});
        }
        //取前k个
        while(k--){
            res.push_back(m_p.top().second);
            m_p.pop();
        }

        return res;
    }
```



### 12.6 二叉树

#### 226.翻转二叉树

```
解题思路:
两种解法，递归和迭代
本质是根右左的处理顺序，在交换之前先保存一下左边节点

迭代法注意交换完先入右边的，这样出来的时候才是先出左边的

难点和细节:二叉树遍历
```

***代码:***

```c++
//递归法
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return nullptr;
        //对每个节点左右交换
        TreeNode *tmp = root->left;
        root->left = invertTree(root->right);
        root->right = invertTree(tmp);
        return root;
    }
    //迭代法
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return nullptr;
        
        stack<TreeNode *> st;
        st.push(root);

        while(!st.empty()){
            TreeNode *node = st.top();
            st.pop();

            swap(node->left,node->right);
            if(node->right) st.push(node->right);
            if(node->left) st.push(node->left);
        }

        return root;
    }
```



#### 101.对称二叉树

```
解题思路:
左右子树都为空，对称
一方为空，不对称
先判断左右子树值相等，然后再递归判断左的左和右的右相等，判断左的右和右的左相等

难点和细节:递归
```

***代码:***

```c++
    bool compare(TreeNode *left,TreeNode *right){
        //左右为空，树对称
        if(!left&&!right) return true;
        //一个为空一个不为空
        if(!left||!right) return false;
        //先判断，然后判断两个子树
        return (left->val==right->val)&&compare(left->left,right->right)&&compare(left->right,right->left);
    }
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root->left,root->right);
    }
```



#### 104.二叉树的最大深度

```
解题思路:
两种思路，一种层序遍历，没处理完一层+1，思路简单不讲解了
第二种递归法，不是很容易理解
首先要知道最大深度取决于什么
要根据左边最深和右边最深，判断哪个更深一些，这样再加上当前节点的1就能算出最大深度然后返回
关键在return max(lmax,rmax) + 1

难点和细节:递归
```

***代码1:***

```c++
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        int res = 0;
        queue<TreeNode *> q;
        q.push(root);

        while(!q.empty()){
            int size = q.size();
            while(size--){
                TreeNode *tmp = q.front();
                q.pop();

                if(tmp->left) q.push(tmp->left);
                if(tmp->right) q.push(tmp->right);
            }
            //当前层处理完毕，层数+1
            res += 1;
        }
        
        return res;
    }
```

***代码2:***

```c++
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        
        //最大深度就是max(左边最大深度,右边最大深度) + 1
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);

        return max(leftMax,rightMax)+1;
    }
```



#### 111.二叉树的最小深度

```
简单题无需讲解过多
需要注意不能把上一道题的代码换成min就解决了
因为两天路径都不存在的时候确实是0+1
但是一旦一条存在那么就是最小的那一条
```

***代码:***

```c++
    int minDepth(TreeNode* root) {
        if(!root) return 0;

        int lmin = minDepth(root->left);
        int rmin = minDepth(root->right);
        //如果有一个子树存在另一个不存在那么最小深度就是存在的子树+1
        if(!root->left)
            return rmin + 1;
        
        if(!root->right)
            return lmin + 1;
        return min(lmin,rmin) + 1;
    }
```



#### 222.完全二叉树的节点个数

```
解题思路:
此题有三种解法，一种普通递归，一种层序，还有一种就是完全二叉树的性质做题，这里只讲最后一种，其他两种的代码贴到下面了

首先我们要清楚完全二叉树有两种形式，一种是满的，一种是非满，也就是最底下一层右边可能有空节点
那问题来了，如何判断满呢？其实可以通过一直左移动求左边深度和一直右移动求右边深度，如果深度相等，说明是满二叉树
如果满二叉树的话说明节点数是2^leftDepth - 1那么这个次方如何表示呢，其实通过2<<leftDepth就可以简单完成
如果非满
那就是递归左右子树，左右子树总有满的情况，所以个数就是左子+右子+当前节点(1)

难点和细节:完全二叉树性质，如何判满
```

***代码1:***

```c++
    //递归法
    if(!root) return 0;
    return countNodes(root->left) + countNodes(root->right) + 1;
```

***代码2:***

```c++
    //层序法
    if(!root) return 0;
    int res = 0;
    queue<TreeNode *> q;
    q.push(root);

    while(!q.empty()){
        int size = q.size();
        while(size--){
            TreeNode *node = q.front();
            q.pop();
            res++;

            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }

    return res;
```

***代码3:***

```c++
int countNodes(TreeNode* root) {
        if(!root) return 0;
        TreeNode *left = root->left;
        TreeNode *right = root->right;
        //开始往左和右递归最大深度
        int leftDepth = 0;
        int rightDepth = 0;
        while(left){
            left = left->left;
            leftDepth++;
        }

        while(right){
            right = right->right;
            rightDepth++;
        }
        //比较最左边和最右边的值

        if(leftDepth == rightDepth){
            //说明是满二叉树

            //return 2 * leftDepth - 1; 
            return (2 << leftDepth) - 1;//这里注意，左移这么多位才是次方，否则调函数
        }

        //非满的完全二叉树,递归左右子树处理
        return countNodes(root->left) + countNodes(root->right) + 1;

    }
```



#### 110.平衡二叉树

```
解题思路:
此题递归法不难
首先要知道平衡的条件
1.左右子树高度差不超过1
2.左右子树也平衡
所以专门写了一个计算最大深度的函数，然后主函数求出左子和右子的最大深度，如果他俩相减的绝对值 > 1则返回false
否则递归左子右子判断平衡

难点和细节:递归，平衡概念
```

***代码：***

```c++
    bool isBalanced(TreeNode* root) {
        if(!root) return true;
        int left = height(root->left);
        int right = height(root->right);
        if(abs(left - right) > 1) return false;
        return isBalanced(root->left)&&isBalanced(root->right);

    }
    int height(TreeNode* node) {
        if(!node) return 0;
        //求左子最大深度和右子最大深度
        int leftDepth = height(node->left);
        int rightDepth = height(node->right);

        //返回最大深度
        return max(leftDepth,rightDepth) + 1;
    }   
```



#### 257.二叉树的所有路径

```
解题思路:
此题虽然是easy，但是用到了回溯思想
我们遍历的顺序是前序遍历，也就是根左右
先处理根，把根添加到路径里，然后做叶子节点的判断决定是否添加结果
然后处理左孩子和右孩子
如果左孩子存在就递归左边，递归结束后记得pop元素，这样左边收集完就会去收集右边
然后右边同理

难点和细节:回溯
```

***代码:***

```c++
	vector<string> res;
    vector<int> path;
    void backTracking(TreeNode *root){
        //根左右

        //先添加当前节点
        path.push_back(root->val);
        //判断是否是叶子节点
        if(!root->left&&!root->right){
            //都不存在才收集结果
            string spath = "";
            for(int i = 0;i < path.size()-1;i++){
                spath += to_string(path[i]);
                spath += "->";
            }
            spath += to_string(path[path.size()-1]);
            res.push_back(spath);
        }
        //左节点存在的话就递归左
        if(root->left){
            backTracking(root->left);
            path.pop_back();
        }
        //右节点存在的话就递归右
        if(root->right){
            backTracking(root->right);
            path.pop_back();
        }
        
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        backTracking(root);
        return res;
    }
```



#### 404.左叶子之和

```
简单题，使用前序遍历
左子之和相加的条件是，左孩子存在，并且左孩子的左和右孩子不存在(即左叶子)就进行收集，否则单纯递归下去左
然后递归下去右
```

***代码:***

```c++
    void FindLeftSum(TreeNode *root,int &leftSum){
        if(!root) return;
        //前序
        //左
        if(root->left){   
            if(!root->left->left&&!root->left->right){
                leftSum += root->left->val;
            }
            FindLeftSum(root->left,leftSum);
        }
        //右
        if(root->right){
            FindLeftSum(root->right,leftSum);
        }
    }
    int sumOfLeftLeaves(TreeNode* root) {
        int leftSum = 0;
        FindLeftSum(root,leftSum);
        return leftSum;
    }
```



#### 513.找树左下角的值

```
解题思路:
此题优先考虑层序遍历，比较简单，这里就讲讲迭代法吧
首先要找到最大层数，还要最左边，我们考虑前序遍历，根的处理是如果是叶子并且深度比最大深度大，就收集结果
左就是递归深度，然后右
这里先左后右的原因是，如果左右同时为最深，那么会先收集左边的，这样右边的判断深度的时候就不大于最大深度了

难点和细节:递归顺序，层序遍历
```

***代码:***

```c++
int findBottomLeftValue(TreeNode* root) {
        int levelFirst = 0;
        queue<TreeNode *> q;
        //考虑层序遍历求层数，然后最后一层第一个出去的就是
        q.push(root);

        while(!q.empty()){
            int size = q.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = q.front();
                q.pop();
                // 记录每行一行第一个元素，直到最后一行
                if (i == 0) levelFirst = node->val; 
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }

        return levelFirst;
    }
```



#### 112.路径总和

```
此题简单题，但是需要理清情况
到了叶子节点并且targetSum归0了说明可以返回true
如果到叶子节点了还不是0说明这条路径不对 返回false
然后由于我们是从左或右递归下来的，得从左右递归判断一下
```

***代码：***

```c++
    bool backTracking(TreeNode *root,int targetSum){
        if(!root->left&&!root->right&&targetSum == 0) return true;
        //如果到叶子节点了还不是0说明这条路径不对
        if(!root->left&&!root->right) return false;
        //前序遍历
        if(root->left){
            if(backTracking(root->left,targetSum-root->left->val))
                return true;
        }

        if(root->right){
            if(backTracking(root->right,targetSum-root->right->val)){
                return true;
            }
        }

        return false;
    }

    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        return backTracking(root,targetSum-root->val);
    }
```



#### 106.从中序和后序遍历构造二叉树

```
解题思路:
本题最需要考虑得就是区间问题，弄清楚这个就没有难度了
我们的参数设计是，中序开头和中序末尾，后序开头和后序末尾，中序是为了确定下标和范围的，而后序是为了求得谁该最先连接

首先进入条件判断，中序头大于中序尾或者后序头大于后序尾则返回空
我们传入的参数中postEnd是用来获得当前元素的，所以拿到值之后先构造节点，从哈希表里求得下标
计算一下左树节点的数量(通过当前节点下标-inStart)，能通过这个数量获得区间

说说左子的区间构造吧，(中序开始没变)，(末尾变了是当前节点下标-1),由于后序是用来取当前值的，后序起始位置应该是不变(postStart),末尾要变，我们从末尾取当前元素，而末尾是什么呢，就是左子元素的数量-1(postStart + leftSum - 1)

右子同理，(当前节点下标+1)，(inEnd)，(postStart + leftSum（这里要说一下，越过左子所有元素开始就是右子了）),
(postEnd - 1)->因为我们开始是从末尾取的一个，所以-1，取下一个右子

难点和细节:区间判断，参数设计
```

***代码：***

```c++
    unordered_map<int,int> m_p;
    TreeNode* build(vector<int>& inorder, vector<int>& postorder,int inStart, int inEnd, int postStart, int postEnd){
        //条件判断
        if(inStart > inEnd||postStart > postEnd){
            return nullptr;
        }
        //求得当前节点得值
        int rootVal = postorder[postEnd];
        TreeNode *root = new TreeNode(rootVal);
        
        //求得当前节点在中序得下标
        int rootIndex = m_p[rootVal];
        //计算左树得数量
        int leftTreeNum = rootIndex - inStart;

        root->left = build(inorder,postorder,inStart,rootIndex - 1,postStart,postStart + leftTreeNum - 1);

        root->right = build(inorder,postorder,rootIndex + 1,inEnd,postStart + leftTreeNum,postEnd-1);

        return root;

    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //遍历中序数组，保存元素对于下标
        for(int i = 0;i < inorder.size();++i){
            m_p[inorder[i]] = i;
        }

        return build(inorder,postorder,0,inorder.size()-1,0,postorder.size()-1);
    }
```



#### 654.最大二叉树

```
解题思路:
此题有点像前序中序和中序后序构建二叉树的题，思路大概一致，无非都是计算左区间和右区间。
通过哈希表拿到当前范围内最大值的下标
递归创建左右子树，左子树的范围是l，index-1
右子树的范围是index+1，r
这样在区间内继续取最大然后递归下去就是最终结果

难点和细节:区间判定，哈希表
```

***代码:***

```c++
	unordered_map<int,int> m_p;//根据值拿到下标
    TreeNode *buildTree(vector<int> &nums,int lBorder,int rBorder){
        if(lBorder > rBorder) return nullptr;
        int maxVal = 0;
        //求得当前范围内得最大值
        for(int i = lBorder;i <= rBorder;++i){
            maxVal = nums[i]>maxVal?nums[i]:maxVal;
        }
        //拿到下标
        int index = m_p[maxVal];
        //创建节点
        TreeNode *node = new TreeNode(maxVal);
        //递归创建左子树，并给定范围
        node->left = buildTree(nums,lBorder,index-1);
        //递归创建右子树，并给定范围
        node->right = buildTree(nums,index+1,rBorder);

        return node;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        for(int i = 0;i < nums.size();++i){
            m_p[nums[i]] = i;
        }
        return buildTree(nums,0,nums.size()-1);
    }
```



#### 617.合并二叉树

```
简单题，不做过多说明
主要想清楚几种情况，然后构造树就行了
```

***代码：***

```c++
    TreeNode *mergeTwoTrees(TreeNode *root1,TreeNode *root2){
        //root1和root2为当前互相比较的节点
        //三种情况
        //情况1，都不存在
        if(!root1&&!root2) return nullptr;
        //情况2，只存在一边
        if(!root1) return root2;
        if(!root2) return root1;

        //情况3，两边都存在
        //合并值
        TreeNode *node = new TreeNode(root1->val + root2->val);
        node->left = mergeTrees(root1->left,root2->left);
        node->right = mergeTwoTrees(root1->right,root2->right);

        return node;
    }

    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        
        return mergeTwoTrees(root1,root2);
    }
```



#### 700.二叉搜索树中的搜索

```
简单题，先根据二叉树的性质进行搜索，然后再构造就好了	
```

***代码:***

```c++
    TreeNode *buildTree(TreeNode *cur){
        if(!cur) return nullptr;

        TreeNode *node = new TreeNode(cur->val);
        node->left = buildTree(cur->left);
        node->right = buildTree(cur->right);

        return node;   
    }
    TreeNode* searchBST(TreeNode* root, int val) {
        //从根节点往下比较
        TreeNode *cur = root;
        
        while(cur){
            //小了往左
            if(val < cur->val){
                cur = cur->left;
            }
            //大了往右
            else if(val > cur->val){
                cur = cur->right;
            }
            else{
                break;
            }
        }

        return buildTree(cur);
    }
```



#### 98.验证二叉搜索树

```
此题有意思，目光不能短浅，仅仅看一个家族内的成员，需要看整根树
解题思路:
维护每一个节点的上界与下界，此节点必须大于下界小于上界，同时左右子树递归处理，也要满足条件
递归的传参是，假如是左子树，要小于父亲，所以上界变为父亲，下界还是父亲的下界
假如是右子树，要大于父亲，所以下界变为父亲，上界还是父亲的上界
难点和细节：维护的上下界，long
```

***代码:***

```c++
    bool isValidBST(TreeNode* root,long left = LONG_MIN,long right = LONG_MAX) {
        if(!root) return true;

        long cur = root->val;

        return cur > left && cur < right &&
            isValidBST(root->left,left,cur) &&
            isValidBST(root->right,cur,right);
    }
```

***代码2***

```
还有一种如下解法
可以考虑中序遍历，左根右
递归到最左边说明是最小了，这个时候更新最大值，如果递归出栈的时候，有值比这个最大值小那就要返回false了
然后递归右子，假如右子没有左子的话，那么第一步left直接跳过了，就是从上往下判断，如果当前值小于maxVal就false了
```



```c++
	long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;

        bool left = isValidBST(root->left);
        // 中序遍历，验证遍历的元素是不是从小到大
        if (maxVal < root->val) maxVal = root->val;
        else return false;
        bool right = isValidBST(root->right);

        return left && right;
    }
```



#### 530.二叉搜索树的最小绝对差

```
解题思路:
此题不难，主要是考察二叉搜索树的性质
最小差值只会出现在三个情况
1.当前节点值-当前节点左子树的最右边
2.当前节点值-当前节点右子树的最左边
3.左右子树递归

其实还有一种思路，二叉搜索树的中序遍历结果是个有序数组，可以直接相邻计算	
难点和细节：二叉搜索树的性质
```

***代码:***

```c++
int getMinimumDifference(TreeNode* root) {
        if (!root) return INT_MAX;
        int left = INT_MAX;
        int right = INT_MAX;
        //最小差值在左子树的最右或者右子树的最左
        if (root->left){
            TreeNode *cur = root->left;
            while(cur->right){
                cur = cur->right;
            }
            left = abs(root->val - cur->val);
        }
            
        if (root->right){
            TreeNode *cur = root->right;
            while(cur->left){
                cur = cur->left;
            }

            right = abs(cur->val - root->val);
        }
            
        int curMin = min(left, right);
        int leftRightMin = min(getMinimumDifference(root->left), getMinimumDifference(root->right));
        // 返回最小
        return min(curMin, leftRightMin);
    }
```



#### 501.二叉搜索树中的众数

```
解题思路:
此题难度为easy，但是有进阶做法
先说简单的做法，就是通过映射，把节点的值和出现次数映射出来，最后统计众数就行
无需额外空间的做法是通过中序遍历，因为二叉搜索树的中序遍历是有序的
所以如果相等，一定相连着，方便计数
定义一个当前计数和一个最多出现次数，此外还需要一个前驱指针用来记录之前的节点以便进行比较
首先就是中序，判断pre和当前节点的值，如果相等则++当前计数，不相等说明之前的节点遍历完了到新的节点了
那么直接置为1，每回更改当前计数后要和当前最大众数做比较，如果大于当前众数，说明以前添加到res里的结果都不能要了
直接清空，然后进入当前众数，但如果次数相等，说明有多个众数，直接进入
完事之后更新前驱节点

难点和细节：二叉搜索树中序遍历
```

***代码1:***

```c++
    vector<int> res;
    void inorder(TreeNode* node, TreeNode*& prev, int& modeCount, int& maxCount) {
        if (!node) return;
        //中序遍历，左
        inorder(node->left,prev,modeCount,maxCount);

        //判断pre和当前节点
        if(prev&&prev->val == node->val){
            //相等则++modeCount(当前计数)
            modeCount++;
        }
        else{
            //不相等则置为1
            modeCount = 1;
        }
        //每次更新完之后，判断是否是众数
        if(modeCount > maxCount){
             //看看是不是比当前众数大，如果大，先把res弹出，在进入新的
            res.clear();
            res.push_back(node->val);
            //更新众数
            maxCount = modeCount;
        }
        else if(modeCount == maxCount){
            //如果等于，直接进
            res.push_back(node->val);
        }
        //更新前一个节点
        prev = node;
        //遍历右边
        inorder(node->right,prev,modeCount,maxCount);

    }
    vector<int> findMode(TreeNode* root) {
        TreeNode *prev = nullptr;
        int modeCount = 0;
        int maxCount = 0;

        inorder(root,prev,modeCount,maxCount);

        return res;
    }
```

***代码2:***

```c++
    unordered_map<int,int> m_p;
    vector<int> res;
    void backTracking(TreeNode *root){
        //直接在map里添加
        if(!root) return;
        m_p[root->val]++;
        backTracking(root->left);
        backTracking(root->right);
        return;
    }
    vector<int> findMode(TreeNode* root) {
        backTracking(root);
        int maxVal = 0;
        for(pair<int,int> p:m_p){
            if(p.second > maxVal) maxVal = p.second;
        }

        for(auto p:m_p){
            if(p.second == maxVal) res.push_back(p.first);
        }
        
        return res;
    }
```

#### 236.二叉树的公共祖先

```
解题思路:
本题不难，重要的是几种情况的考虑
1.要找的节点在当前节点的左子树和右子树中，也就是left和right都返回了，说明公共祖先就是root(当前节点)
2.要找的两个节点只在左子树中，那么往下递归找left的时候，碰到root==p||root==q的时候直接返回root就行，因为此时当前节点right为空，全部要找的节点都在左子树，那么你找到的第一个节点就是它的祖先
3.要找的两个节点都在右子树中，同样的道理不多赘述

还有一种解释比较好理解，祖先吗，无非两种情况，俩节点在左右里，或者都在一边里，那么我们求一下当前root的left和right就行了，也就是往左和往右递归，碰到那个节点就返回给它就行了，如果左节点存在右不存在，说明都在左了，那你返回的第一个节点就是祖先，如果左右都存在，那就说明root是祖先，或者右存在左不存在，一样道理


难点和细节：几种情况的分析，对于祖先出现的理解
```

***代码***

```c++
    TreeNode *recur(TreeNode *root, TreeNode* p, TreeNode* q){
        if(!root) return nullptr;
        if(root == p||root == q) return root;

        TreeNode *left = recur(root->left,p,q);
        TreeNode *right = recur(root->right,p,q);

        if(!left) return right;
        if(!right) return left;

        return root;
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return recur(root,p,q);
    }
```

#### 235.二叉搜索树的最近公共祖先

```
解题思路:
和上一道题差不多，甚至还有些简化
明确几种情况
1.一个节点大于当前，另外一个小于当前，由于二叉搜索树的性质，那么两节点一定分散在两侧，返回当前节点
2.两节点都小于当前节点，那么直接往左递归并返回
3.两节点都大于当前节点，那么直接往右递归并返回

需要主要，如果递归的过程中碰到了相等的元素，那么可以直接返回

难点和细节：搜索树性质，祖先问题
```

***代码:***

```c++
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root) return nullptr;
        //前序与当前节点比较值
        if(root == p||root == q) return root;
        if(root->val > p->val&&root->val < q->val||root->val > q->val&&root->val < p->val){
            return root;
        }
        else if(root->val < p->val&&root->val < q->val){
            //右
            return lowestCommonAncestor(root->right,p,q);
        }
        else if(root->val > p->val&&root->val > q->val){
            //左
            return lowestCommonAncestor(root->left,p,q);
        }

        return nullptr;
    }
```



#### 701.二叉搜索树中的插入操作

```
数据结构类型的题，不讲
```

***代码:***

```c++
TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode *node = new TreeNode(val);
        if(!root){
            return node;
        }

        TreeNode *cur = root;
        TreeNode *pre = nullptr;
        while(cur){
            pre = cur;
            if(val > cur->val){
                //右找
                cur = cur->right;
            }
            else if(val < cur->val){
                //左找
                cur = cur->left;
            }
            else{
                //相等，返回空
                return nullptr;
            }
        }

        //pre为待插入节点的父亲
        if(val > pre->val){
            pre->right = node;
        }
        else if(val < pre->val){
            pre->left = node;
        }

        return root;
    }
```



#### 450.删除二叉搜索树中的节点

```
解题思路:
此题是二叉搜索树的删除
采用递归法删除节点
1、根据搜索树的性质，找到要删除的节点，在找的时候注意递归调用删除函数返回的是你去的方向
2、找到要删除的节点后判断几种情况，1子和0子还有2子
3、这里的精髓在于!root->left这种情况包含了0子和左空右不空的情况
4、接着在判断另外一子的情况
5、最后就是2子进行替换，把要删除的节点和右最小替换之后，向右方向删除那个替换值

难点和细节：搜索树删除
```

***代码:***

```c++
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root) return nullptr;
        //先找到要删除的节点
        if(key < root->val){
            root->left = deleteNode(root->left,key);
        }
        else if(key > root->val){
            root->right =  deleteNode(root->right,key);
        }
        else{
            //找到要删除的节点了
            if(!root->left){
                //此情况包含双子都不存在，或者left不存在right存在
                TreeNode *tmp = root->right;
                delete root;
                return tmp;
            }
            
            if(!root->right){
                TreeNode *tmp = root->left;
                delete root;
                return tmp;
            }

            //此时双子都存在
            TreeNode *temp = root->right;
            //找右最小来替换
            while(temp->left){
                temp = temp->left;
            }

            root->val = temp->val;

            root->right = deleteNode(root->right,temp->val);
        }

        return root;
    }
```

#### 669.修剪二叉搜索树

```
解题思路:
此题不要陷入误区，什么样的误区呢，就是重构这颗树，也就是删除节点
我们直接开始递归，假如root在区间内，那么就不用处理了，只需要递归左子右子
但是假如小于low，由于搜索树，左边的肯定也小于low，所以直接递归右子
大于high同理，各自返回

难点和细节：区间处理
```

***代码:***

```c++
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (!root) return nullptr;

        if(root->val < low){
            //说明root的左边都不行了，直接递归右子就行
            TreeNode *right = trimBST(root->right,low,high);
            return right;
        }

        if(root->val > high){
            //说明root的右边都不行了，直接递归左子就行
            TreeNode *left = trimBST(root->left,low,high);
            return left;
        }
        //此时root在区间内，只需要处理左右子树就可以了
        root->left = trimBST(root->left,low,high);
        root->right = trimBST(root->right,low,high);

        return root;
    }
```



108.将有序数组转换为二叉搜索树

```
简单题
其实就是划分区间，找到中间节点，，然后左右构造就行
```

***代码:***

```c++
    TreeNode* ArrayToBSTHelper(vector<int>& nums,int start,int end) {
        if(start > end) return nullptr;

        int mid = start + (end - start)/2;
        TreeNode *node = new TreeNode(nums[mid]);

        node->left = ArrayToBSTHelper(nums,start,mid-1);
        node->right = ArrayToBSTHelper(nums,mid+1,end);

        return node;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return ArrayToBSTHelper(nums,0,nums.size()-1);
    }
```



#### 538.将二叉搜索树转换为累加树

```
难度medium，但是简单题，直接反中序遍历，右根左，依次重新赋值就行
```

***代码：***

```c++
    int sum = 0;

    TreeNode* convertBST(TreeNode* root) {
        if(!root) return nullptr;
        //右根左
        convertBST(root->right);

        //根
        sum += root->val;
        root->val = sum;
    
        convertBST(root->left);
        return root;
    }
```

### 12.7 回溯

#### 77.组合

```
解题思路:
上来先套回溯模板，组合问题由于不能重复，[1,2][2,1]一样，所以参数需要startIndex防止回头
这里的剪枝需要理解一下
剩余的元素(n-i) >= 还需要取得元素(k-path.size())则能取

难点和细节：模板
```

***代码:***

```c++
	vector<int> path;
    vector<vector<int>> result;
    void backTracking(int n,int k,int startIndex){
        //由于组合无序，所以不能取重复的，[1,2][2,1]一样
        if(path.size() == k){
            result.push_back(path);
            return;
        }

        //当前层次处理
        for(int i = startIndex;i <= n - (k - path.size()) + 1;++i){
            path.push_back(i);
            //下一层
            backTracking(n,k,i+1);

            path.pop_back();
        }
    }

    vector<vector<int>> combine(int n, int k) {
        backTracking(n,k,1);
        return result;
    }
```



#### 216.组合Ⅲ

```
和上一道题区别不大，多个总和条件
```

***代码:***

```c++
	vector<int> path;
    vector<vector<int>> result;
    void backTracking(int k,int n,int sum,int startIndex){
        if(sum == n&&path.size() == k){
            result.push_back(path);
            return;
        }

        if(path.size() > k) return;

        for(int i = startIndex;i <= 9;++i){
            path.push_back(i);
            //隐藏sum的回溯
            backTracking(k,n,sum+i,i+1);

            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        backTracking(k,n,0,1);
        return result;
    }
```



#### 17.电话号码的组合

```
解题思路:
乍一看以为有点难的一道题，但是实际上还是经典组合问题
先要定义电话号码映射表
开始回溯，收集结果的条件是给的数字字符串的长度和已收集的长度相等
由于是组合问题，所以不能回头取，需要个startIndex控制
startIndex作为选定的数字，处理当前层次的时候先把startIndex对应的数字转为int型
然后找到对应的字母集合，开始当前层次的处理，添加进路径就ok
然后开始递归，进入下一层，也就是下一个集合，那么通过startIndex+1拿到下一个集合
循环结束就选完了

难点和细节：基本回溯
```

***代码:***

```c++
private:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
    vector<string> result;
    string path;
public:
    void backTracking(const string &digits,int startIndex){
        if(path.size() == digits.size()){
            result.push_back(path);
            return;
        }

        //取出对应index里的字符
        //例如23先转为2，在转下一个
        int index = digits[startIndex] - '0';

        //处理本层次
        for(int i = 0;i < letterMap[index].size();++i){
            path.push_back(letterMap[index][i]);
            backTracking(digits,startIndex+1);
            path.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if (digits.size() == 0) {
            return result;
        }
        backTracking(digits,0);
        return result;
    }
```



#### 39.组合总和

```
解题思路:
普通的回溯题目，不一样的点在于在组合的基础上又加了当前数可以重复选取
那么就要注意递归到下一层的条件了，是i本身，这样随着循环次数增加i也不会回头，并且也能取到自己
进阶一点是剪枝操作
注意需要排序，排序完之后假如pathSum + candidates[i] > target了说明后续的数全部大于target没必要在遍历了
所以遍历条件在并上一条pathSum + candidates[i] <= target

难点和细节：剪枝操作，重复和组合结合
```

***代码:***

```c++
    vector<vector<int>> res;
    vector<int> path;
    int pathSum;
    void backTracking(vector<int>& candidates, int target,int startIndex){
        //收集条件
        if(pathSum == target){
            res.push_back(path);
            return;
        }

        //考虑加个终止条件
        if(pathSum > target) return;

        //开始本层处理
        for(int i = startIndex;i < candidates.size()&& sum + candidates[i] <= target;++i){
            path.push_back(candidates[i]);
            pathSum += candidates[i];
            //处理下一层，由于可以重复取
            backTracking(candidates,target,i);
            pathSum -= candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backTracking(candidates,target,0);
        return res;
    }
```

***代码优化:***

```c++
vector<vector<int>> res;
    vector<int> path;
    int pathSum;
    void backTracking(vector<int>& candidates, int target,int startIndex){
        //收集条件
        if(pathSum == target){
            res.push_back(path);
            return;
        }

        //考虑加个终止条件
        if(pathSum > target) return;

        //开始本层处理
        //pathSum + candidates[i] > target说明后续的数加上当前值都大于target没必要继续了
        for(int i = startIndex;i < candidates.size()&& pathSum + candidates[i] <= target;++i){
            path.push_back(candidates[i]);
            pathSum += candidates[i];
            //处理下一层，由于可以重复取
            backTracking(candidates,target,i);
            pathSum -= candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        //剪枝操作需要排序
        sort(candidates.begin(), candidates.end()); // 需要排序
        backTracking(candidates,target,0);
        return res;
    }
```



#### 40.组合总和Ⅱ

```
此题不做过多讲解，来说说和之前组合问题不一样的地方吧
这个题的描述是candidates 中的每个数字在每个组合中只能使用一次 。
也就是说假如我的集合是1，1，2，5
那么有可能会取到1(下标0),2,5或者1(下标1),2,5
所以我们要考虑去重，显然需要借助排序，如果当前数和前一位的数不同就不能取
是这样吗?
准确来说是，同一层次前后相同的不能取，因为1，2，5这三个数是在不同的递归栈内的不同循环里
也就是我的代码中为什么写了i != startIndex的原因，因为如果等于startIndex说明我这一层才第一次取数
1，1，6这个结果就能说明这一点，总不能这个集合不取吧，它也符合结果
```

***代码:***

```c++
    vector<vector<int>> res;
    vector<int> path;
    int pathSum;
    void backTracking(vector<int>& candidates, int target,int startIndex){
        if(pathSum == target){
            res.push_back(path);
            return;
        }

        if(pathSum > target) return;

        //开始本层处理
        for(int i = startIndex;i < candidates.size();++i){
            if(i != startIndex&&candidates[i] == candidates[i-1]){
                //同层次不能取
                continue;
            }
            path.push_back(candidates[i]);
            pathSum += candidates[i];
            backTracking(candidates,target,i+1);
            pathSum -= candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        //先排序
        sort(candidates.begin(),candidates.end());
        backTracking(candidates,target,0);
        return res;
    }
```



#### 131.分割回文串

```
解题思路:
这道题和之前的回溯不一样的地方在于要"切割"
主要函数有两个，1是判断回文，2就是回溯
回溯套模板，什么时候收集结果呢
在startIndex超出字符串范围，也就是不能再分割的时候
之后开始正常回溯的处理，只不过我们现在不是一个元素一个元素的处理，而是一个串一个串的处理
通过substr进行切割，每层startIndex开始，切i-startIndex+1那么长，例如aab，最开始startIndex = 0
逐个切就是，a，aa，aab，确保所有情况都能取到
进入下一层通过i+1

难点和细节：切割
```

***代码:***

```c++
    vector<vector<string>> res;
    vector<string> path;
    
    bool isRecur(string str){
        int i = 0;
        int j = str.size()-1;
        while(i < j){
            if(str[i] != str[j]){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }

    void backTracking(string s,int startIndex){
        //收集结果，如果标记>=size
        if(startIndex >= s.size()){
            res.push_back(path);
            return;
        }

        for(int i = startIndex;i < s.size();++i){
            //开始切割
            string str = s.substr(startIndex,i-startIndex+1);
            if(!isRecur(str)) continue;
            path.push_back(str);
            backTracking(s,i+1);
            path.pop_back();
        }
    }
    vector<vector<string>> partition(string s) {
        backTracking(s,0);
        return res;
    }
```



#### 93.复原ip地址

```
解题思路:
本题算是比较不一样的题，但是明显是分割问题
两个函数，一个判断当前分割的子串是否有效，一个回溯
子串是否有效不用细讲，三个条件判断就好
讲讲回溯，比较精髓的地方在与这个.
我们在参数的第三个位置放了个点的数量，然后当合法的时候直接在原串上加.
那么什么时候收集结果呢，就是已经有了三个点的时候，正常分成四段切每段都合法才能加结果，但是由于三个点就要判断(四个点的话末尾会多一个出来)，所以相当于最后一段还没有进行判断，那我们就判断一下，如果最后一段合法就添加

回溯当前层的处理先要切割，如果切出来的子串合法，那么就开始插入点，开始回溯，这里注意，要从i+2的地方开始，因为我们直接动的原串，加了个点相当于多了一位，完事后弹出.

难点和细节：切割，加点，收集条件
```

***代码：***

```c++
	vector<string> res;
    string path;
    bool isValid(string s,int start,int end){
        if (start > end) {
            return false;
        }
        if (s[start] == '0' && start != end) { // 0开头的数字不合法
            return false;
        }
        
        for(int i = start;i <= end;++i){
            if(s[i] < '0'||s[i] > '9') return false;
        }

        //再看数目
        string tmp = s.substr(start,end-start+1);
        int num = stoi(tmp);
        if(num < 0||num > 255) return false;
        return true;
    }

    //此题也是分割
    void backTracking(string &s,int startIndex,int point){
        if(point == 3){
            //并且最后一段合法
            if(isValid(s,startIndex,s.size()-1)){
                res.push_back(s);
            }
            return;
        }

        //本层处理
        for(int i = startIndex;i < s.size();++i){
            //如果切割合法
            if(isValid(s,startIndex,i)){
                //像i的下一个插入逗点
                s.insert(s.begin()+i+1,'.');
                //开始回溯,i+2的位置，因为动的原串
                backTracking(s,i+2,point+1);
                s.erase(s.begin()+i+1);
            }
            else{
                //不合法，当前层不用再考虑了
                break;
            }
        }
    }
    vector<string> restoreIpAddresses(string s) {
        if (s.size() < 4 || s.size() > 12) return res;
        backTracking(s,0,0);
        return res;
    }
```



#### 78.子集

```
标准的回溯模板题，不一样的地方就是收集条件
此处无收集条件，有一个结果就收集一个
要在回溯最开始的时候就收集一下结果，要不然会漏掉空
```

***代码:***

```c++
    vector<vector<int>> result;
    vector<int> path;
    void backTracking(vector<int>& nums,int startIndex){
        //收集条件(子集)
        result.push_back(path);

        if(startIndex >= nums.size()) return;

        //本层处理
        for(int i = startIndex;i < nums.size();++i){
            path.push_back(nums[i]);
            backTracking(nums,i+1);
            path.pop_back();
        }

    }

    vector<vector<int>> subsets(vector<int>& nums) {
        backTracking(nums,0);
        return result;
    }
```



#### 90.子集Ⅱ

```
解题思路:
其实还是经典的模板题组合去重，比上题多了个去重逻辑，这里就讲讲去重吧
例如1，2，2，5
那么2，5和2，5正常取的话是可能会重复的
我们这里借助排序，把相同的元素排放在一起，这样同层次的相同元素只要跳过就不会取重复了
如何判断同层，借助i != startIndex，相同的判断这里就不提及了
难点和细节：去重
```

***代码:***

```c++
    vector<vector<int>> res;
    vector<int> path;
    //去重
    void backTracking(vector<int> &nums,int startIndex){
        //收集
        res.push_back(path);

        if(startIndex >= nums.size()) return;

        for(int i = startIndex;i < nums.size();++i){
            //去重，同层次前后不能相同
            if(i != startIndex&&nums[i] == nums[i-1]){
                continue;
            }
            path.push_back(nums[i]);
            backTracking(nums,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        res.clear();
        path.clear();
        sort(nums.begin(),nums.end());
        backTracking(nums,0);
        return res;
    }
```



#### 491.非递减子序列

```
解题思路:
这道题和常规模板题不同，包括去重逻辑，收集结果，递减判断
先说说收集条件
题目说至少包含两个元素，最开始写的时候return了，但是如果return了之后下面的更多元素的情况就走不到了
再说说如何去重
此题不让对数组排序，要的是原来的无序数组中的非递减序列，所以不能排序和前后判断了
此时需要依靠哈希表，如unordered_set自带的去重逻辑，在进入循环的时候进行判断一下本层存不存在这个元素，如果存在则跳过
然后就是非递减条件，只需要和当前路径集的最后的元素进行比较，如果小于最后的元素那么说明是递减，不能收集continue

难点和细节：哈希去重，收集条件
```

***代码:***

```c++
	vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int> &nums,int startIndex){
        //至少两个元素
        if(path.size() >= 2){
            res.push_back(path);
            //这里不能return,收集了两个还要继续收集
            //不然收集两个就停止了
            //return;
        }

        if(startIndex >= nums.size()) return;
        //由于不能用排序去重了，那么同层次使用set去重
        //记录本层使用过的元素
        unordered_set<int> mset;

        for(int i = startIndex;i < nums.size();++i){
            //如果非递减，并且本层使用过，跳过此元素
            if(!path.empty()&&nums[i] < path.back()
               ||mset.find(nums[i]) != mset.end()) continue;

            mset.insert(nums[i]);
            path.push_back(nums[i]);
            backTracking(nums,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        res.clear();
        path.clear();
        backTracking(nums,0);
        return res;    
    }
```



#### 46.全排列

```
解题思路:
回溯系列的第一道排列题
先说收集条件，长度相等的时候添加结果
这里与组合问题不一样的地方在于，不再需要startIndex，因为1，2和2，1是不同的排列
既然不同层之间都是从头取得，那么假如1，2，3这个集合，我从2开始取，那假如到下一层的时候，当前集合是2，1，接下来遍历到的2取不取呢？当然不取，那么就要依靠used数组了，使用过了之后，不同层级之间就不能取了
难点和细节：排列模板
```

***代码:***

```c++
	vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int> &nums,vector<bool> &used){
        //收集
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }

        //因为不同层从头遍历可能遍历到自己本身，需要used数组

        for(int i = 0;i < nums.size();++i){
            if(used[i] == true) continue;

            used[i] = true;
            path.push_back(nums[i]);
            backTracking(nums,used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        res.clear();
        path.clear();
        vector<bool> used(nums.size(),false);
        backTracking(nums,used);
        return res;
    }
```



#### 47.全排列Ⅱ

```
解题思路:
排列问题的进阶版，主要是多了去重逻辑
涉及到去重就要考虑一下排序，因为这里说可包含重复的数字，那么1，2，1这个组合就重复，需要排序成1，1，2方便去重
去重逻辑实际上就是加了(i > 0&&used[i-1] == false&&nums[i] == nums[i-1])
首先来看used[i-1] == false，这里不同层级是可以取相同元素的，例如1，1，2，也就是下标0是true时可以取下标1的1
但如果前一个值是false，说明同层次这个值的情况已经考虑过了，并且前后数值相等，那么就不能再取了
难点和细节：去重
```

***代码:***

```c++
    vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int>& nums,vector<bool> &used){
        //收集
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }

        for(int i = 0;i < nums.size();++i){
            if(used[i] == true||i > 0&&used[i-1] == false&&nums[i] == nums[i-1]) continue;
            used[i] = true;
            path.push_back(nums[i]);
            backTracking(nums,used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        res.clear();
        path.clear();
        sort(nums.begin(),nums.end());
        vector<bool> used(nums.size(),false);
        backTracking(nums,used);
        return res;
    }
```



#### 37.解数独

```
解题思路:
此题为hard，能用回溯思路做，实际上就是深搜，如下方法比较简单
先说判断可以放数的条件，行列的不说了，说说3*3方格
拿给定的行和列/3在*3就能得到行列的起始位置，接下来只要遍历的时候各往外扩展三格就好了
回溯部分其实没什么难的，主要还是这个返回值bool的设计
先遍历行在遍历列，如果是.那说明可以放，在开始遍历1-9九个数看看哪个是valid的，如果合法
对应位置放这个数字，然后开始回溯，这里注意，如果找到了一个合法的矩阵就返回true了没必要在判断下去
如果九个数试完了之后都不行的话就返回false；
难点和细节：返回值设计
```

***代码:***

```c++
    bool isValid(vector<vector<char>> &board,int row,int col,char num){
        //循环变量就是列
        //先判断行
        for(int i = 0;i < 9;++i){
            if(board[row][i] == num){
                return false;
            }
        }

        //在判断列
        for(int j = 0;j < 9;++j){
            if(board[j][col] == num){
                return false;
            }
        }
        //3*3
        int startRow = (row/3)*3;
        int startCol = (col/3)*3;

        for(int i = startRow;i < startRow + 3;++i){
            for(int j = startCol;j < startCol + 3;++j){
                if(board[i][j] == num){
                    return false;
                }
            }
        }

        return true;
    }
    bool backTracking(vector<vector<char>> &board){
        for(int i = 0;i < board.size();++i){
            for(int j = 0;j < board[0].size();j++){
                if(board[i][j] == '.'){
                    //此时说明可以放
                    for(char c = '1';c <= '9';c++){
                        if(isValid(board,i,j,c)){
                            board[i][j] = c;
                            //找到一组符合条件的矩阵直接返回
                            if(backTracking(board)) return true;
                            board[i][j] = '.';
                        }
                    }
                    //如果9个数都不行就返回false
                    return false;
                }
            }
        }

        //遍历完都没有返回false，说明找到合适的位置了
        return true;
    }
    void solveSudoku(vector<vector<char>>& board) {
        backTracking(board);
        return;
    }
```



### 12.8 贪心

#### 455.分发饼干

```
easy题目
贪心，先对两个数组进行排序，然后双指针
s的最左边一定是饼干最小的，一个个和孩子的最小胃口匹配，这样最后一定是能满足最多孩子的数目
或者从后往前推也行，大的优先匹配大的
```

***代码:***

```c++
int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int i = 0;
        int j = 0;
        int res = 0;
        while(i < g.size()&&j < s.size()){
            if(s[j] >= g[i]){
                //能满足
                i++;
                j++;
                res++;
                continue;
            }
            //不能满足
            j++;
        }

        return res;
    }
```



#### 376.摆动序列

```
解题思路:
这道题很绕，虽然代码很短，但是情况很多需要具体分析
首先求摆动的意思就是求峰值，这里我们默认最后是有一个峰值的，要不然例如1，2两个元素，根据pre和cur的计算方法只能算出来一个。也就是一个平坡，上坡
其实简单理解结果的计算条件就是下坡上坡和上坡下坡，在此基础上可能会有平坡来干扰但其实是一样的
条件分两种，平坡|下坡&&上坡     上坡|平坡&&下坡，这两种情况都可以++结果
但是这里有个坑，如果根据这个算法，那么单调递增中间又出现平坡的时候会多进行一次计算
所以我们要出现峰值的时候再更新preDiff(这里需要重点理解)

难点和细节：情况分析
```

***代码:***

```c++
int wiggleMaxLength(vector<int>& nums) {
        if(nums.size() <= 1) return nums.size();
        int curDiff = 0;
        int preDiff = 0;
        //默认右边有一个峰值
        //例如1，5这种情况
        int result = 1;

        for(int i = 0;i < nums.size()-1;++i){
            curDiff = nums[i+1] - nums[i];

            //下坡上坡和上坡下坡
            if(preDiff <= 0&&curDiff > 0||preDiff >= 0&&curDiff < 0){
                ++result;
                //出现峰值的时候在更新preDiff
                preDiff = curDiff;
            }
        }

        return result;
    }
```



#### 53.最大子数组的和

```
开贪，贪的是什么?局部最优是什么?
当我们当前的连续数组的和是正的时候，说明可能对后面累加和有帮助，那么就要记录一下当前最大值
如果和出现负数了，说明之前的子数组和对我们后面累加完全没有帮助，直接置当前累加和为0就行
```

***代码：***

```c++
    int maxSubArray(vector<int>& nums) {
        //连续

        //局部最优是什么
        //就是和还是正的，一旦变负说明不是局部最优

        int path = 0;
        int max = INT_MIN;

        for(int i = 0;i < nums.size();++i){
            path += nums[i];
            if(path > max) max = path;
            //小于0之后清0，前面的集合不可取
            if(path <= 0) path = 0;
        }

        return max;
    }
```

#### 122.买卖股票的最佳时机

```
贪心思路
只需要拆解每天的利润，只要有正的利润就进行收集，收集到最后一定是最大的
```

***代码:***

```c++
    int maxProfit(vector<int>& prices) {
        int res = 0;
        //把利润拆为每天
        //这样只取正的利润就能拿到最大利润
        for(int i = 1;i < prices.size();++i){
            //i从1开始，才有利润
            if((prices[i] - prices[i-1]) > 0)
                res += (prices[i] - prices[i-1]);
        }
        
        return res;
    }
```



#### 55.跳跃游戏

```
解题思路:
这道题目关键点在于：不用拘泥于每次究竟跳几步，而是看覆盖范围，覆盖范围内一定是可以跳过来的，不用管是怎么跳的。
循环条件遍历的是覆盖范围，每到一个节点就更新一下范围，最后只要能覆盖到最后一个节点就成功
```

***代码:***

```c++
    bool canJump(vector<int>& nums) {
        //看跳跃的最大范围
        int cover = 0;
        if(nums.size() == 1) return true;
        //这里的小于条件是cover，确保跳跃区间连续能跳到
        for(int i = 0;i <= cover;i++){
            cover = max(cover,i+nums[i]);
            if(cover >= nums.size()-1) return true;
        }
        return false;
    }
```



#### 45.跳跃游戏Ⅱ

```
解题思路:
抽象的贪心。
此题主要还是理解覆盖范围，2，3，1，1，4
实际上就是找当前范围能走到的数之内的最大数，在走下一步
记录两个变量，一个当前覆盖的最远距离，一个下一步能覆盖的最远距离
当你走到了当前范围的最大距离就需要走下一步了
总之贪心就是很抽象
难点和细节：。。。
```

***代码:***

```c++
    int jump(vector<int>& nums) {
        if(nums.size() == 1) return 0;
        int curDistance = 0;//当前覆盖的最远距离
        int res = 0;//步数
        int nextDistance = 0;//下一步能覆盖的最远距离下标
        for(int i = 0;i < nums.size()-1;++i){
            //这里是nums.size()-1
            //因为如果走到末尾了说明覆盖范围又结束了，res又要++，多加一次
            nextDistance = max(nextDistance,i + nums[i]);
            if(i == curDistance){
                //也就是说，当前走到头了才需要走下一步
                curDistance = nextDistance;
                res++;
            }
        }
        return res;
    }
```



#### 1005.K次取反后最大化的数组和

```
解题思路:
这道题还好
关键是要对数组元素按照绝对值排序，这样的话例如2,-3,-1,5,-4  排序完之后就是 5 -4 -3 2 -1
我们只需要从前往后遍历，如果当前元素为负数并且K还有值那么就取反
如果遍历完一轮k还有值说明数组里已经全是正数了，由于我们的排序规则，数组最后的元素一定是最小的
那么如果k为奇数，直接反转最后的元素就行
偶数直接返回

难点和细节：绝对值排序
```

***代码:***

```c++
static bool compare(int a,int b){
        return abs(a) > abs(b);
    }
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end(),compare);

        for(int i = 0;i < nums.size();i++){
            if(nums[i] < 0&&k > 0){
                nums[i] = -nums[i];
                k--;
            }
        }

        if(k % 2 == 1) nums[nums.size()-1]*=-1;

        return accumulate(nums.begin(),nums.end(),0);
    }
```



#### 134.加油站

```
解题思路:
这道题不能想复杂
什么是局部最优解，当前res[i]的curSum累加和一旦小于0，说明0-i之间的加油站都不能成为起始站点，因为中间就会断掉
全局最优就是找到起始点
我们要观察的不是gas或者cost，而是它们逐位相减得到的一个数组
也就是说如果res[i]大于0说明可以从当前站点走到下一个站点
那我们累计一个当前和，如果当前和小于0说明前面这个区间一定会断，那么从i+1再看
但是现在知道从哪里出发了，怎么知道从那个位置出发就一定能回到当前位置呢，毕竟我们的遍历又不会回头
这就要依靠一个total变量了，记录每个站点的res，如果到最后total是大于0的，说明一定有位置可以绕一圈
否则返回-1
难点和细节：当前累加和控制区间
```

***代码:***

```c++
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int resIndex = 0;
        int totalSum = 0;
        int curSum = 0;

        for(int i = 0;i < gas.size();i++){
            totalSum += gas[i] - cost[i];
            curSum += gas[i] - cost[i];

            if(curSum < 0){
                //说明i之前的位置不能取
                curSum = 0;
                resIndex = i + 1;
            }
        }

        if(totalSum < 0) return -1;
        

        return resIndex;
    }
```



#### 135.分发糖果

```
解题思路:
此题难度为hard，但是把遍历顺序弄明白就好了
首先1.比较左孩子比右孩子大，然后2.比较右孩子比左孩子大的情况
情况1需要从后向前遍历，因为左孩子和右孩子比较的话需要用到右孩子的糖果数作为条件来让当亲元素的糖果数+1
情况2从前向后遍历，因为拿右孩子和左孩子比较需要用到左孩子的糖果数
同时，如果当前元素的糖果数已经大于比较的那个元素了就不用再+1了

难点和细节：遍历顺序，左比右，右比左共两轮
```

***代码:***

```c++
    int candy(vector<int>& ratings) {
        vector<int> candy(ratings.size(),1);
        //左比右大的情况
        for(int i = ratings.size()-2;i >= 0;i--){
            if(ratings[i] > ratings[i+1]&&candy[i] <= candy[i+1]){
                candy[i] = candy[i+1] + 1;
            }
        }
        //右比左大的情况
        for(int i = 1;i < ratings.size();i++){
            if(ratings[i] > ratings[i-1]&&candy[i] <= candy[i-1]){
                candy[i] = candy[i-1] + 1;
            }
        }

        return accumulate(candy.begin(),candy.end(),0);
    }
```



#### 860.柠檬水找零

```
贪心，这道题也不用往复杂了想，直接判断每种零钱的情况就行
5块钱不用找，手里5块的数目++
10块钱，找5块--，手里10块的数目++
20块，这个需要找15，这里用到了贪心思路，我们需要先判断10 + 5这种情况，优先消耗10块的，因为5块的更有用
最终达成全局最优
```

***代码1：***

```c++
//最开始的猪b写法
bool lemonadeChange(vector<int>& bills) {
        //需要找零的钱数
        vector<int> bill_cnt(3);//0-5  1-10  2-20
        for(int i = 0;i < bills.size();i++){
            //先收入货币
            bill_cnt[bills[i]/10]++;  
            //再判断找零
            bills[i] -= 5;


            //只会有这两种情况，因为货币只有5 10 20 各-5
            if(bills[i] == 5){
                if(bill_cnt[0] <= 0) return false;
                bill_cnt[0]--;
            }
            else if(bills[i] == 15){
                if(bill_cnt[0] > 0&&bill_cnt[1] > 0){
                    bill_cnt[0]--;
                    bill_cnt[1]--;
                }
                else if(bill_cnt[0] >= 3){
                    bill_cnt[0] -= 3;
                }
                else{
                    return false;
                }
                
            }

        }

        return true;
    }
```

***代码2:***

```c++
bool lemonadeChange(vector<int>& bills) {
        //零钱数目
        int five = 0,ten = 0;

        for(int bill:bills){
            if(bill == 5){
                five++;
            }

            if(bill == 10){
                if(five <= 0) return false;
                five--;
                ten++;
            }

            if(bill == 20){
                //局部最优，先消耗10块的，因为5块更万能
                if(ten&&five) five--,ten--;
                else if(five >= 3) five -= 3;
                else return false;
            }
        }

        return true;
    }
```



#### 406.根据身高重建队列

```
解题思路:
这道题还有点意思
先考虑根据身高排序，高的在前，那为什么要这样呢
例如如下的排完序后的数组
[[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]
接下来我们在靠k的值进行插入对应的数组位置，例如[5,2]它前面的数一定都是比它大的，那么插入到下标2的时候就不怕有比它小的了
这里涉及到了很多次的插入，为了效率我们使用list来进行插入
难点和细节：身高排序，按nums[i][1]进行插入
```

***代码：***

```c++
static bool m_compare(vector<int> &a,vector<int> &b){
        if(a[0] == b[0]) return a[1] < b[1];//身高相同，前面人少的在前面
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(),people.end(),m_compare);
        //使用链表提高插入效率
        list<vector<int>> que;

        for(int i = 0;i < people.size();++i){
            int position = people[i][1];

            auto it = que.begin();
            while(position --){
                //寻找插入位置
                it++;
            }
            que.insert(it,people[i]);
        }

        return vector<vector<int>>(que.begin(),que.end());
    }
```



#### 452.用最少数量的箭引爆气球

```
解题思路:
局部最优解，根据区间前者进行小到大的排序
记录当前最小的右区间，然后遍历逐个比较左区间，一旦当前左区间比最小右区间大了
说明应该射一支箭，并更新最小右区间为当前右区间
光这样还不行，因为排序完之后区间可能是[1,6][2,4]虽然最小右区间大于当前的2也就是一只箭能射两个气球
但是下一轮在比较的时候再拿6比就错了，因为有了更小的区间4，所以需要min一下
res初始为1是因为从第一个气球开始最少也要射一只箭，当前气球的开始位置大于上一个气球的结束位置，那么就需要多射一支箭
难点和细节：最小右区间与当前左区间做比
```

***代码：***

```c++
	static bool m_compare(vector<int> &a,vector<int> &b){
        if(a[0] == b[0]) return a[1] < b[1];
        return a[0] < b[0];
    }
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(),points.end(),m_compare);

        int res = 1;
        int end = points[0][1];
        for(int i = 1; i < points.size(); ++i){
            if(end < points[i][0]){
                res++;
                end = points[i][1];
            } 
            else {
                end = min(end, points[i][1]);
            }
        }

        return res;
    }
```



#### 435.无重叠区间

```
这道题和上一道题非常像，按照左边界和右边界进行排序都可以，这里使用的左边界排序
上一道题弓箭的数量其实是非交叉区间的数量
而这一道题就是问减去多少个区间才能达到都不交叉区间
如何算重叠区间呢，就是当前的最小右边界大于遍历的左区间说明重叠了，需要移除
可是究竟是移除上一个还是遍历的这个呢，就要看看它们的右区间了，例如[1,3]  [1,2]
最开始最小右区间是3,3>1所以重叠，需要去重，去谁?当然是右边界更大的那个，这样后面重叠概率才能更小，更新右边界
之后假如不重叠呢?例如[1,3][3,5]    [4,6]
不重叠的话我们的右区间要实时更新，如果不更新的话，最开始一直是3，那么遍历到[4,6]的时候，[3,5]和它重叠
但是右区间不更新是3，小于4判定不重叠，这样结果就错了，所以不重叠的话右边界要实时更新，重叠要看右边界大小
```

***代码：***

```c++
function<bool(vector<int>&,vector<int>&)> fun;
    static bool m_compare(vector<int> &a,vector<int> &b){
        return a[0] < b[0];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        fun = m_compare;
        sort(intervals.begin(),intervals.end(),fun);
        int res = 0;
        int minRightBorder = intervals[0][1];
        //怎么算重叠，当前最小区间，大于下一个的开头
        for(int i = 1;i < intervals.size();i++){
            if(minRightBorder > intervals[i][0]){
                //说明重叠，需要移除
                res++;
                if(intervals[i][1] < minRightBorder)
                    minRightBorder = intervals[i][1];
            }
            else{
                //不重叠的时候需要进行更新
                minRightBorder = intervals[i][1];
            }
        }

        return res;
    }
```



#### 736.划分字母区间

```
解题思路:
此题第一次遇见的话可能措手不及，感觉和暴力思想差不多，就是通过哈希表把时间复杂度降下来了
首先我们要定义一个哈希表，存放每个字母最后出现的位置
定义一个变量，代表当前字母区间的末尾

开始遍历，比较当前字母区间末尾和遍历的字母末尾，如果字母末尾没超过区间，说明所有的当前字母都在区间内部了
如果超过，就更新区间，当遍历的i走到当前边界说明，这个区间内的所有字母都不会在后面出现了，添加结果

难点和细节：哈希记录字母的最后出现下标做区间判定
```

***代码：***

```c++
vector<int> partitionLabels(string s) {
        unordered_map<char,int> mp;
        //记录每个字母最后出现的位置
        for(int i = 0;i < s.size();i++){
            mp[s[i]] = i;
        }

        vector<int> res;
        //分片段
        int curBorder = 0;
        int curNum = 0;
        for(int i = 0;i < s.size();i++){
            //先对区间内的第一个字母求最后出现的位置
            if(mp[s[i]] > curBorder){
                //如果大于当前区间的最后位置，更新区间
                curBorder = mp[s[i]];
            }

            curNum++;
            if(i == curBorder){
                //说明走到当前区间的边界了,添加结果
                res.push_back(curNum);
                curNum = 0;
            }
            
        }
        return res;
    }
```



#### 56.合并区间

```
解题思路:
和之前几道区间题差不多，都是变体
还是根据vector[i][0]排序，小的在前，这样重叠区间更好判断
从头开始维护左右边界
当右边界大于当前遍历的元素的左边界的时候说明有重叠区间
这时候左边区间不用动，因为根据左区间排序，一定更小，但是右区间要更新成更大的那一个
当无重叠区间的时候，把之前的左右边界的结果添加到结果集中，这样能防止重复添加相同结果，不重叠时候的左右边界一定是最后更新完的重叠最大区间
然后左右边界都进行更新
由于我们遍历到最后一个元素添加的是前面的边界结果，也就是最后一次的区间没添加，出循环添加

难点和细节：去重添加
```

***代码：***

```c++
vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        sort(intervals.begin(),intervals.end(),
            [](vector<int> &a,vector<int> &b)->bool{
                return a[0] < b[0];
            }
        );
        int leftBorder = intervals[0][0]; //取最小的s
        int rightBorder = intervals[0][1]; //取最大的
        for(int i = 1;i < intervals.size();++i){

            if(rightBorder >= intervals[i][0]){
                //重叠，更新大的右边界
                //左边界不用更新，一定是之前的更小
                rightBorder = max(rightBorder,intervals[i][1]);
            }
            else{
                //不重叠
                //先添加之前的边界，然后开始新一轮的判断
                res.push_back({leftBorder,rightBorder});
                leftBorder = intervals[i][0];
                rightBorder = intervals[i][1];
            }
        }
        
        //最后的一个vector的时候没添加，放到外面添加
        res.push_back({leftBorder,rightBorder});

        return res;
    }
```



#### 738.单调递增的数字

```
解题思路:
也是一道有意思的技巧题目
这里的贪心思想体现在，如果当前数是大于下一个数的，说明递减序列，为了获得一个更小值，需要--当前数，并把下一个数置为9，这样就是小于之前数的最大值了
这道题的关键其实是遍历顺序，假如332，如果正向遍历，到第二个3的时候发现比2大，那么就变成了329，然后还不能回头了，结果自然不对，所以我们需要进行反向遍历
难点和细节：遍历顺序，贪心思想
```

***代码:***

```c++
int monotoneIncreasingDigits(int n) {
        string str_n = to_string(n);

        //标记赋值9的开始位置
        int flag = str_n.size();

        for(int i = str_n.size()-1;i > 0;i--){
            if(str_n[i-1] > str_n[i]){
                //前一个大于后一个，递减了
                flag = i;
                str_n[i-1]--;
            }
        }

        for(int i = flag;i < str_n.size();i++){
            str_n[i] = '9';
        }

        return stoi(str_n);
    }
```



#### 968.监控二叉树

```
解题思路:
本题hard，乍一看很难，再看还是不简单，看了思路，恍然大悟，没几行代码，主要是分析情况
首先，从哪里开始安装摄像头呢?从上往下?可以看到给的例子的摄像头都是在中间的，没在叶子上，因为如果在叶子上的话，会浪费掉一层覆盖，满足这个条件的遍历顺序，只有后序遍历
规定状态0为无覆盖状态，1是有摄像头状态，2是有覆盖状态
我们的宗旨是，让父亲去处理孩子的覆盖情况，举例，俩孩子都覆盖了但是本身没被覆盖，这个时候我们并不会在本身添加摄像头，而是把问题传递给当前节点的父亲处理

开始情况分析，空节点的状态是什么呢?为了不在叶子节点上安装摄像头，那么空节点要确保是覆盖状态，所以返回2
接下来后序求值左右节点返回情况
如果左孩子右孩子都被覆盖，把问题传给爷爷，当前节点返回0，表示未覆盖状态
如果左孩子或者右孩子有一个没被覆盖，那么当前节点也就是它们的父亲就要出手了，摄像头++，返回1
如果左孩子或者右孩子中带摄像头，那么父亲节点就被覆盖了，返回2

最后还有一种情况，由于节点的覆盖情况我们交给节点的父亲来做，但是根节点没父亲，当我们后序遍历到根节点的时候发现，左子右子都被覆盖了的话，那么根节点是不是会返回0，也就是未被覆盖状态，那不行啊，我们需要在根节点再添加一个摄像头，最终返回结果

难点和细节：状态规定，遍历顺序，空节点判断，根节点判断
```

***代码:***

```c++
//规定 0为无覆盖状态，1是有摄像头状态，2是有覆盖状态
    int result;
    int traversal(TreeNode *cur){
        //空节点为有覆盖状态，为了不在叶子节点上装监控
        if(!cur) return 2;

        int left = traversal(cur->left);
        int right = traversal(cur->right);

        //情况判断
        if(left == 2&&right == 2){
            //如果左子右子都覆盖了，说明父亲不用安装摄像头，交给爷爷来做
            return 0;
        }
        else if(left == 0||right == 0){
            //左子或者右子有一个没覆盖，就得把当前节点变为摄像头
            result++;
            return 1;
        }
        else{
            //左右节点可能一个有摄像头，或者都有摄像头,那当前节点就是已覆盖状态
            return 2;
        }
        
        return -1;
    }
    int minCameraCover(TreeNode* root) {
        //后序遍历
        result = 0;
        //后序遍历完之后还有一种情况
        //那就是根节点的左右子都是已覆盖状态，但那么正常来说会返回0
        //但是根还需要个摄像头
        if(traversal(root) == 0){
            result++;
        }

        return result;
    }
```

